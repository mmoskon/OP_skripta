\chapter{Delo z datotekami}

\section{Zakaj pisati v datoteke in brati iz njih?}

Programi, ki smo jih napisali do zdaj, so podatke hranili le za čas svojega izvajanja v t.i. \emph{delovnem pomnilniku}. Ko se je nek program končal, so ti podatki izginili in ko smo program ponovno zagnali, smo morali te podatke ponovno zgenerirati, npr. tako, da smo jih prebrali od uporabnika (če smo bolj natančni, so podatki izginili, ko smo resetirali okolje IDLE npr. z zagonom drugega ali istega programa). Ko smo torej dopolnjevali telefonski imenik z novimi vnosi, se je imenik ob končanju programa izbrisal in dodani vnosi so izginili. To običajno predstavlja problem zaradi več razlogov:
\begin{itemize}
    \item Ko se program neha izvajati, podatki izginejo. V primeru imenika se ta torej ob vsakem ponovnem zagonu programa resetira na začetno, npr. prazno, vsebino.
    \item Nimamo varnostnih kopij podatkov. Če se npr. telefon, ki uporablja naš imenik, ugasne, moramo celotno vsebino imenika ustvariti od začetka.
    \item Podatkov, ki smo jih ustvarili v enem programu, ne moremo oziroma težko uporabljamo v drugih programih. 
\end{itemize}
Na srečo lahko podatke v svojih programih iz delovnega pomnilnika oziroma iz vsebine spremenljivk kadarkoli shranimo v t.i. \emph{trajni pomnilnik} oziroma po domače na \emph{disk}. S tem omogočimo njihovo trajno hrambo, kar pomeni, da lahko do teh podatkov pridemo tudi po zaključku izvajanja programa, na disku podatki ostanejo tudi po izklopu računalnika, do njih pa lahko pridemo tudi iz drugih programov. 

Kako pa podatke shranimo na disk? Podobno, kot smo do zdaj na disk shranjevali naše programe v obliki datotek s končnico \texttt{py}, lahko v (druge) datoteke shranjujemo tudi podatke, s katerimi delamo. 

Tako shranjene datoteke lahko kasneje v svojih programih preberemo in s tem \emph{obnovimo} stanje svojega delovnega pomnilnika oziroma določimo vrednosti spremenljivk na podlagi vsebine datoteke. Dodatna prednost branja podatkov iz datotek je to, da se nam zdaj ni treba več zanašati na vnos podatkov s strani uporabnika, ampak lahko podatke, ki jih želimo obdelati, v svoje programe preberemo kar iz datotek. Če bi npr. želeli pregledati podatke o povprečnih mesečnih plačah v Sloveniji, najpogostejših imenih ali inflaciji, bi te lahko prenesli iz spletne strani Statističnega urada republike Slovenije (SURS, \url{https://www.stat.si/statweb}), jih v svojem programu prebrali in ustrezno obdelali. V tem poglavju si bomo pogledali kako podatke iz datoteke prebrati in kako v datoteko podatke zapisati.

\section{Kaj je datoteka?}

Datoteke predstavljajo osnovni način zapisovanja podatkov na disku (ali na kakšnem drugem mediju). Datoteke predstavljajo trajno hrambo podatkov, omogočajo prenašanje podatkov med različnimi uporabniki in lahko vsebujejo različne tipe podatkov od teksta, besedil, slik in filmov, do datotek, ki jih operacijskih sistem uporablja za svoje delovanje. Ponavadi tip datoteke označuje njena končnica. Programi v Pythonu na primer uporabljajo končnico \texttt{py}, slike pa končnice kot so \texttt{jpg}, \texttt{png} ali \texttt{gif}. 

V grobem lahko datoteke ločimo v dve skupini, in sicer na \emph{tekstovne datoteke} in \emph{binarne datoteke}. V obeh primerih vsebino datoteke predstavlja zaporedje števil, ki si jih lahko v primeru tekstovnih datotek interpretiramo kot zaporedje znakov oziroma nek (neoblikovan) tekst. Primer tekstovne datoteke je recimo datoteka s končnico \texttt{py} ali datoteka s končnico \texttt{txt}. Za tekstovne datoteke velja, da jih lahko odpremo z beležnico ali beležnici podobnimi orodji (npr. \emph{Notepad++}) in je njihova vsebina bolj ali manj berljiva. Kaj pa binarne datoteke? V skupino binarnih datotek uvrščamo vse ostalo, npr. slike, filme in oblikovana besedila. Če poskusite z beležnico odpreti datoteko s končnico \texttt{docx} (besedilo oblikovano z orodjem Microsoft Word), boste hitro videli, da to ni tekstovna datoteka. Tako kot pri tekstovnih datotekah je zapis s števili uporabljen tudi pri binarnih datotekah. Različna je le interpretacija teh števil. Medtem, ko lahko vsebino tekstovnih datotek orodja, kot je beležnica, enostavno dekodirajo kot zaporedje znakov, potrebujemo za binarne datoteke druga orodja oziroma programe, ki znajo njihovo vsebino dekodirati, glede na tip zapisa. Ena orodja pretvarjajo številke v slike, druga v filme, tretja v oblikovano besedilo. Katero orodje bo posamezno datoteko ob dvojnem kliku nanju odprlo, določa njena končnica. Če se končnica datoteke ne ujema z njeno vsebino, bo orodje vrnilo napako ali pa v najboljšem primeru prikazalo nekaj nenavadnega, podobno kot če datoteko s končnico \texttt{docx} odpremo z beležnico. 

\section{Tekstovne datoteke}
Tekstovne datoteke torej vsebujejo neoblikovan tekst, ki lahko predstavlja na primer neko besedilo, program v Pythonu ali pa podatke, ki smo jih zgenerirali tekom delovanja našega programa. V okviru spoznavanja osnov programiranja se bomo neposredno ukvarjali zgolj s tekstovnimi datotekami. 

\section{Odpiranje datoteke}

Če želimo neko datoteko v našem programu prebrati ali vanjo pisati, jo moramo najprej odpreti. To lahko naredimo z vgrajeno funkcijo \texttt{open}, ki ji bomo za začetek podali zgolj ime datoteke, do katere želimo dostopati. Naredimo tekstovno datoteko \texttt{stevila.txt} s sledečo vsebino\footnote{Datoteko naredimo tako, da odpremo beležnico, vpišemo vsebino datoteke in datoteko shranimo.}:
\begin{lstlisting}[showstringspaces=false,numbers=left]
4
5.6
2
100
15
\end{lstlisting}
Datoteko shranimo v mapo kamor pač najpogosteje shranjujemo svoje datoteke. Zdaj jo poskusimo odpreti v Pythonu:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> open('stevila.txt')
FileNotFoundError: [Errno 2] No such file or directory: 
'stevila.txt'
\end{lstlisting}
Python pravi, da datoteke ne najde, čeprav smo jo pravkar ustvarili. Problem je v tem, da Python datoteko išče v svoji trenutni \emph{delovni mapi}, ki očitno ni enaka tisti, kamor smo mi shranili svojo datoteko\footnote{Do trenutne delovne mape lahko pridemo preko funkcije \texttt{getcwd} iz vgrajenega modula \texttt{os}.}. Problem bi lahko rešili na dva načina.

Prvi način je, da Pythonu podamo \emph{absolutno pot} do lokacije datoteke. Pythonu smo do datoteke v gornjem primeru podali t.i. \emph{relativno pot}, kar pomeni, da bo datoteko iskal relativno glede na trenutno delovno mapo. Če je njegova delovna mapa npr. \texttt{C:$\backslash$Windows$\backslash$system32}, pričakuje, da se datoteka nahaja tu. Lahko pa Pythonu podamo celotno oziroma \texttt{absolutno} pot. Če smo datoteko npr. shranili v mapo \texttt{C:$\backslash$Programiranje}, jo zdaj lahko odpremo takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> open('C:\\Programiranje\\stevila.txt')
<_io.TextIOWrapper name='C:\\Programiranje\\stevila.txt' mode='r'
encoding='cp65001'>
\end{lstlisting}
Tokrat smo datoteko le našli. Mimogrede, zakaj je bilo pri podajanju poti potrebno podati dve poševnici (\texttt{$\backslash$}). Kot smo videli v prejšnjem poglavju, poševnico Python obravnava kot začetek posebnega znaka. Z njo lahko npr. zapišemo tabulator (\texttt{$\backslash$t}) ali pa znak za novo vrstico (\texttt{$\backslash$n}). Če bi radi zapisali poševnico pa v niz enostavno vpišemo dve poševnici (\texttt{$\backslash\backslash$}).

Drugi način, ki je nekoliko enostavnejši in bolj pogost, je, da pač spremenimo svojo delovno mapo in potem do datoteke podamo relativno pot. To ponavadi pomeni, da podamo samo ime datoteke (kot v primeru, ko je Python javil napako). Kako pa spremenimo trenutno delovno mapo? Načeloma nam za to ni potrebno posebej skrbeti, saj bo IDLE ob zagonu programa Pythonovo delovno mapo avtomatsko zamenjal za tisto, v kateri se program nahaja. Če bomo datoteko odprli iz programa, ki se bo nahajal v isti mapi kot datoteka, lahko torej podamo zgolj njeno ime. Če torej naredimo program \texttt{branje.py} in ga shranimo v mapo, v katero smo prej shranili \texttt{stevila.txt}, lahko iz njega datoteko odpremo takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
open('stevila.txt')
\end{lstlisting}

\section{Branje datoteke}
Datoteko smo torej uspešno odprli, zdaj pa jo bomo poskusili prebrati. Dostopanje do datoteke lahko izvedemo preko objekta, ki ga vrne funkcija \texttt{read}. Če hočemo datoteko prebrati, moramo temu objektu prirediti neko ime, preko katerega ga bomo lahko kasneje še poklicali. Takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
f = open('stevila.txt')
\end{lstlisting}
Do metod za delo z datoteko lahko zdaj dostopamo preko imena \texttt{f}. Prvi način za branje datoteke je uporaba metode \texttt{read}, ki prebere datoteko od začetka do konca in vrne niz z njeno vsebino. V našem primeru bo rezultat sledeč:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.read()
'4\n5.6\n2\n100\n15'
\end{lstlisting}
To je torej zapisano v datoteki. Niz vsebuje števila, ki so med seboj ločena z znaki za novo vrstico \texttt{$\backslash$n}. Če bi želeli imeti lepši izpis, bi stvar izpisali s funkcijo \texttt{print}, ki znake za novo vrstico izpiše kot nove vrstice. Poskusimo:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> print(f.read())

\end{lstlisting}
Zakaj se tokrat ni nič izpisalo? Objekt za dostopanje do datoteke za imenom \texttt{f} beleži, do kje je bila datoteka že prebrana. Datoteko lahko namreč beremo tudi po kosih (npr. vrstico po vrstico), pri čemer nočemo, da bi vedno brali npr. samo prvo vrstico, ampak bi radi slej ko prej prišli do konca datoteke. Ker smo našo datoteko že prebrali, jo moramo za ponovno branje ponovno odpreti. Ker je trenutna delovna mapa zdaj že enaka mapi, kjer se nahaja naša datoteka, lahko odpiranje tokrat naredimo kar iz ukazne vrstice:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> print(f.read())
4
5.6
2
100
15
\end{lstlisting}

Že prej smo omenili, da lahko datoteko beremo tudi po vrsticah. Lahko npr. uporabimo metodo \texttt{readline}:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.readline()
''
\end{lstlisting}
Tole spet ne deluje, ker se nahajamo na koncu datoteke. Ponovno jo odprimo in preberimo prvo vrstico:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f.readline()
'4\n'
\end{lstlisting}
Branje po vrsticah lahko izvedemo tudi z zanko \texttt{for}. Takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> for vrstica in f:
	print(vrstica)
5.6

2

100

15
\end{lstlisting}
Prva vrstica seveda manjka, ker smo jo prej prebrali že z metodo \texttt{readline}. Zakaj se v izpisu pojavlja prazna vrstica? En znak za prazno vrstico je prispevala funkcija \texttt{print}, drugega pa smo dobili iz prebrane datoteke. Znake za prazno vrstico lahko iz niza, ki predstavlja trenutno prebrano vrstico, odstranimo z metodo \texttt{strip}, ki odstrani prazen prostor pred začetkom in po koncu \emph{prave} vsebine niza:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> for vrstica in f:
	print(vrstica.strip())
4
5.6
2
100
15
\end{lstlisting}

Zadnja metoda, preko katere lahko preberemo datoteko, je metoda \texttt{readline}, ki podobno kot metoda \texttt{read} prebere celo datoteko, jo razbije po vrsticah in te zapiše v seznam.
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f.readlines()
['4\n', '5.6\n', '2\n', '100\n', '15']
\end{lstlisting}

Datoteko lahko torej preberemo na več različnih načinov, pri čemer je vsem skupno to, da vsebino datoteke preberejo kot niz. Če bi želeli vsebino obravnavati kot kaj drugega, jo bomo morali prej ustrezno obdelati (podobno kot moramo npr. v ustrezen podatkovni tip pretvoriti rezultat funkcije \texttt{input}).

Poskusimo branje na zgledu.
\begin{zgled}
Napiši funkcijo \texttt{povprecje}, ki kot argument prejme niz z imenom datoteke in izračuna povprečje števil, ki so shranjena v datoteki. Predpostavljaš lahko, da je vsako število v datoteki zapisano v svoji vrstici. V primeru, da je datoteka prazna, naj funkcija vrne število 0.
\end{zgled}
\begin{resitev}
Funkcijo lahko napišemo s sprehodom čez vrstice, pri čemer vsebino vsake vrstice prištevamo skupni vsoti, ki jo na koncu delimo s številom vrstic. Vsebino vrstice moramo prej seveda očistiti (metoda \texttt{strip}) in pretvoriti v število (funkcija \texttt{float}). 
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def povprecje(ime_datoteke):
    f = open(ime_datoteke)
    s = 0
    n = 0
    for vrstica in f:
        stevilo = float(vrstica.strip())
        s += stevilo
        n += 1
    if n > 0:
        return s/n
    else:
        return 0
\end{lstlisting}
\end{resitev}

Kaj pa če bi imeli v eni vrstici več števil? V tem primeru je potrebno vrstico prej še razbiti na posamezna števila. To lahko naredimo z uporabo metode \texttt{split}, ki jo pokličemo nad posamezno vrstico in ji kot argument podamo ustrezno ločilo.

\begin{zgled}
Napiši funkcijo \texttt{povprecje}, ki kot argument prejme niz z imenom datoteke in izračuna povprečje števil, ki so shranjena v datoteki. Predpostavljaš lahko, da je v posamezni vrstici lahko zapisano več števil, ki so med seboj ločena z vejicami.
\end{zgled}
\begin{resitev}
Tokrat bomo posamezno vrstico z metodo \texttt{split} razbili na seznam, čez katerega se bomo sprehodili z ugnezdeno zanko \texttt{for}. Še vedno pa moramo posamezen element tega seznama pred prištevanjem skupni vsoti pretvoriti v število.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def povprecje(ime_datoteke):
    f = open(ime_datoteke)
    s = 0
    n = 0
    for vrstica in f:
        vrstica = vrstica.strip()
        for element in vrstica.split(","):
            stevilo = float(element)
            s += stevilo    
            n += 1
    if n > 0:
        return s/n
    else:
        return 0
\end{lstlisting}
\end{resitev}

Poskusimo rešiti še težave, ki smo jih imeli s telefonskim imenikom (pa tega nismo vedeli).
\begin{zgled}
Napiši funkcijo \texttt{preberi\_imenik}, ki kot argument prejme niz z imenom datoteke, ki vsebuje varnostno kopijo telefonskega imenika. Funkcija naj datoteko prebere in vrne slovar, v katerem so ključi imena oseb, vrednosti pa njihove telefonske številke zapisane kot nizi. Predpostavljaš lahko, da so podatki v datoteki zapisani tako, da posamezna vrstica vsebuje ime osebe, ki je od telefonske številke osebe ločeno z vejico. Pri tem se v eni vrstici nahajajo zgolj podatki ene osebe.
\end{zgled}
\begin{resitev}
Podobno kot v prejšnjem zgledu bomo s posamezno vrstico naredili sledeče:
\begin{itemize}
    \item odstranili bomo znak za novo vrstico z metodo \texttt{strip};
    \item vrstico bomo razbili na seznam nizov glede na uporabljeno ločilo (\texttt{','}) z metodo \texttt{split};
    \item seznam nizov bomo razpakirali in uporabili kot veleva navodilo naloge.
\end{itemize}

\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def preberi_imenik(ime_datoteke):
    f = open(ime_datoteke)
    imenik = {} # prazen slovar
    for vrstica in f:
        vrstica = vrstica.strip() # odstrani '\n'
        seznam = vrstica.split(',')
        ime = seznam[0]
        stevilka = seznam[1]
        imenik[ime] = stevilka # dodajanje vnosa
    return imenik
\end{lstlisting}
Funkcijo bi lahko še nekoliko izboljšali. Podobno, kot lahko razpakiramo terke, lahko razpakiramo tudi sezname. Torej lahko spremenljivkama \texttt{ime} in \texttt{stevilka} vrednosti priredimo kar v eni vrstici:
\begin{lstlisting}[language=Python, showstringspaces=false]
ime, stevilka = vrstica.split(',')
\end{lstlisting}
Če želimo, da funkcija deluje, tudi v primeru, ko datoteka vsebuje prazne vrstice, moramo pred obdelavo posamezne vrstice preveriti, če ta slučajno ni prazna. Po odstranjevanju znaka za novo vrstico torej preverimo neenakost s praznim nizom:
\begin{lstlisting}[language=Python, showstringspaces=false]
if vrstica != '':
\end{lstlisting}
To lahko krajše zapišemo kar takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
if vrstica:
\end{lstlisting}
Zapišimo celotno rešitev:
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def preberi_imenik(ime_datoteke):
    f = open(ime_datoteke)
    imenik = {} # prazen slovar
    for vrstica in f:
        vrstica = vrstica.strip() # odstrani '\n'
        if vrstica: # vrstica ni prazna?
            ime, stevilka = vrstica.split(',') # razpakiraj
            imenik[ime] = stevilka # dodajanje vnosa
    return imenik
\end{lstlisting}
\end{resitev}

\section{Pisanje v datoteko}

Pisanje v datoteko lahko izvedemo z metodo \texttt{write}, ki ji kot argument podamo niz, ki ga želimo v datoteko zapisati. Poskusimo:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f.write(6)
TypeError: write() argument must be str, not int
\end{lstlisting}
Ravnokar smo rekli, da moramo metodi \texttt{write} podati \textbf{niz}, ki ga želimo zapisati. Če hočemo torej v datoteko zapisati število, ga moramo prej pretvoriti v niz s funkcijo \texttt{str}. Poskusimo še enkrat z nizom: 
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f.write('6')
io.UnsupportedOperation: not writable
\end{lstlisting}
Tokrat smo dobili drugo napako. Vidimo, da pisanje ni mogoče, ker smo datoteko odprli za branje. Več informacij o odprti datoteki, lahko izvemo preko spremenljivke, v katero smo datoteko odprli:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f
<_io.TextIOWrapper name='stevila.txt' mode='r' encoding='cp65001'>
\end{lstlisting}
Iz izpisa vidimo, da smo odprli datoteko z imenom \texttt{'stevila.txt'} (kar že vemo) in da je \texttt{mode} oziroma način odpiranja datoteke enak vrednosti \texttt{'r'}, ki se nanaša na branje oziroma \emph{read}. Način odpiranja datoteke lahko funkciji \texttt{open} nastavimo z izbirnim argumentom \texttt{mode}, ki je privzeto enak vrednosti \texttt{'r'}. Če argumenta ne nastavimo, bomo torej datoteko odprli za branje. Pogosto uporabljena načina odpiranja datoteke sta še \texttt{'w'} oziroma pisanje \angl{write} in \texttt{'a'} oziroma dodajanje \angl{append}. Pisanju bi lahko, če bi bili nekoliko bolj natančni, rekli tudi prepisovanje, saj bomo s takim načinom odpiranja obstoječo datoteko prepisali. Dodajanju bi v podobnem kontekstu lahko rekli dopisovanje, saj bomo obstoječi datoteki vsebino dodajali (na koncu obstoječe vsebine). Pri obeh načinih pa zdaj napake, če datoteka s podanim imenom ne bo obstajala, ne bomo dobili, ampak bo Python to datoteko pač ustvaril. Poskusimo zdaj v datoteko \texttt{'stevila.txt'} zapisati par števil. Najprej jo odpremo za pisanje:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt', mode = 'w')
\end{lstlisting}
Zdaj pa pišimo:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.write('1')
1
>>> f.write('2')
1
>>> f.write('3')
1
>>> f.write('45')
2
\end{lstlisting}
Vsakič, ko pokličemo metodo \texttt{'write'} ta vrne število znakov, ki smo jih zapisovali. Ko zdaj datoteko \texttt{stevila.txt} odpremo z beležnico (ali beležnici podobnim orodjem), vidimo, da je ta prazna. Ko smo datoteko odprli za prepisovanje, je obstoječa vsebina izginila. Potem smo vanjo nekaj pisali. Zakaj je datoteka kljub pisanju še vedno prazna? Pravilo lepega dela z datotekami je, da jih po vsakem odpiranju tudi zapremo za kar lahko uporabimo metodo \texttt{close}. Pri branju to ni nujno potrebno, saj se bo datoteka zaprla avtomatsko, ko bo iz našega imenskega prostora izginila spremenljivka, preko katere smo datoteko najprej odprli in potem brali (najkasneje, ko bomo resetirali okolje IDLE). Pri pisanju pa se lahko zgodi, da bo vsebina datoteke brez eksplicitnega zapiranja datoteke ostala prazna. Ker je pisanje v datoteko počasna operacija, Python, kot smo že navajeni, to v določeni meri optimizira oziroma pohitri. Ko od njega zahtevamo pisanje v datoteko, namreč raje piše v medpomnilnik \angl{buffer}, katerega vsebino bo v dejansko datoteko Python zapisal bodisi takrat, ko se bo nabralo malo več podatkov, da se mu bo splačalo to zapisati v datoteko, ali pa takrat, ko bomo datoteko zaprli, saj s tem povemo, da vanjo ne bomo več pisali. Če želimo, da se naša števila v datoteko zagotovo zapišejo, jo moramo torej zapreti:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.close()
\end{lstlisting}
Ko zdaj odpremo datoteko, vidimo, da se je prejšnja vsebina datoteke prepisala -- seveda, saj smo datoteko odprli za prepisovanje. V njej vidimo sledečo vsebino:
\begin{lstlisting}[showstringspaces=false,numbers=left]
12345
\end{lstlisting}
To ni tisto kar smo hoteli? Mogoče ne, je pa to tisto, kar smo zahtevali. Metoda \texttt{write} namreč v datoteko zapiše točno tisto, kar od nje zahtevamo. Če bi želeli števila zapisati vsako v svojo vrstico, bi morali zraven vsakega števila zapisati tudi znak za novo vrstico (\texttt{$\backslash$n}). Takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.write('1')
ValueError: I/O operation on closed file.
\end{lstlisting}
Ker smo datoteko zaprli, zdaj vanjo ne moremo več pisati. Pred ponovnim pisanjem, jo moramo torej spet odpreti:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt', mode='w')
>>> f.write('1\n')
2
>>> f.write('2\n')
2
>>> f.write('3\n')
2
>>> f.write('45\n')
3
\end{lstlisting}
Datoteko moramo na koncu seveda spet zapreti
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.close()
\end{lstlisting}
Zdaj je njena vsebina sledeča:
\begin{lstlisting}[showstringspaces=false,numbers=left,showlines=true]
1
2
3
45

\end{lstlisting}
Datoteka se konča s prazno vrstico, v katero smo skočili za nizom \texttt{45}. Dodajmo v datoteko še par števil. Če želimo v datoteko novo vsebino dodajati k obstoječi vsebini, jo moramo odpreti za dopisovanje (\texttt{mode='a'}).
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt', mode='a')
>>> f.write('55\n')
3
>>> f.write('133\n')
4
>>> f.write('-6.98\n')
6
>>> f.close()
\end{lstlisting}
Ko datoteko ponovno odpremo z beležnico, vidimo, da smo v njej dobili tri nove vrstice:
\begin{lstlisting}[showstringspaces=false,numbers=left,showlines=true]
1
2
3
45
55
133
-6.98

\end{lstlisting}

Povadimo pisanje še na zgledu.
\begin{zgled}
Napiši funkcijo \texttt{nakljucna}, ki kot argument prejme niz z imenom datoteke in celo število, ki podaja število naključnih števil, ki naj jih funkcija zapiše v datoteko s podanim imenom. Funkcija naj v vsako vrstico v datoteki zapiše največ 10 naključnih celih števil iz intervala od 1 do 100.
\end{zgled}
\begin{resitev}
Naključna števila bomo generirali z uporabo funkcije \texttt{randint} modula \texttt{random}. V datoteko bomo pisali po eno število naenkrat. Po vsakem pisanju lahko zapišemo tudi presledek, na vsakih 10 pisanj pa bomo zapisali znak za novo vrstico.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
# uvažanje modulov vedno delamo izven funkcij
from random import randint

def nakljucna(ime_datoteke, n):
    f = open(ime_datoteke, mode='w') # odpri za prepisovanje
    for i in range(1,n+1): # zanko ponovimo n-krat
        st = randint(1,100) # naključno število od 1 do 100
        niz = str(st) # število moramo pretvoriti v niz
        f.write(niz) # niz zapišemo v datoteko 
        if i % 10 == 0: # ali je čas za novo vrstico
            f.write('\n')
        else:
            f.write(' ')
    f.close() # datoteko na koncu zapremo
\end{lstlisting}
\end{resitev}

Metoda \texttt{write} torej v datoteko zapiše točno tisto, kar ji podamo, vedno pa ji moramo podati točno en podatek tipa \texttt{str}. Če bi želeli naenkrat zapisati več podatkov, jih moramo torej pred tem sami združiti. V določenih primerih bi bilo veliko bolj priročno, če bi lahko v datoteko pisali na enak način, kot smo stvari izpisovali na zaslon, tj. s funkcijo \texttt{print}. Ta sprejema vrednosti poljubnega tipa, poleg tega pa ji lahko podamo več vrednosti, ki jih bo med sabo združila (privzeto z ločilom \texttt{' '}). Izkaže se, da lahko za pisanje v datoteke uporabimo tudi funkcijo \texttt{print}. Pri tej moramo opcijskemu argumentu z imenom \texttt{file} prirediti spremenljivko, v katero smo datoteko odprli\footnote{Opcijski argument \texttt{file} funkcije \texttt{print} je privzeto postavljen na vrednost \texttt{sys.stdout}, kar pomeni, da pišemo na standardni izhod -- v našem primeru je to konzola okolja IDLE.} Poskusimo na prejšnjem zgledu.
\begin{zgled}
Napiši funkcijo \texttt{nakljucna}, ki kot argument prejme niz z imenom datoteke in celo število, ki podaja število naključnih števil, ki naj jih funkcija zapiše v datoteko s podanim imenom. Funkcija naj v vsako vrstico v datoteki zapiše največ 10 naključnih celih števil iz intervala od 1 do 100. Za pisanje v datoteko uporabi funkcijo \texttt{print}.
\end{zgled}
\begin{resitev}
Rešitev je zelo podobna kot prej, le da nam tokrat števil ni potrebno pretvarjati v nize, funkcija \texttt{print} pa tudi sama poskrbi za pisanje presledkov in novih vrstic (le pravilno jo moramo poklicati).
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
# uvažanje vedno delamo izven funkcij
from random import randint

def nakljucna(ime_datoteke, n):
    f = open(ime_datoteke, mode='w') # odpri za prepisovanje
    for i in range(1,n+1): # zanko ponovimo n-krat
        st = randint(1,100) # naključno stevilo od 1 do 100
        if i % 10 == 0: # ali je čas za novo vrstico
            print(st, file=f) # nova vrstica
        else:
            print(st, end=' ', file=f) # presledek 
    f.close()
\end{lstlisting}
\end{resitev}

Za konec dopolnimo še zgled s telefonskim imenikom.
\begin{zgled}
Napiši funkcijo \texttt{shrani\_imenik}, ki kot argument prejme niz z imenom datoteke, ki naj vsebuje varnostno kopijo telefonskega imenika in slovar, v katerem so ključi imena oseb, vrednosti pa njihove telefonske številke. Funkcija zapiše imenik v datoteko s podanim imenom, in sicer tako, da vsaka vrstica vsebuje podatke o eni osebi, pri čemer je ime od telefonske številke ločeno z vejico.
\end{zgled}
\begin{resitev}
V funkciji se bomo sprehodili čez cel imenik in v vsako vrstico zapisali ime in telefonsko številko. Ker sta ime in telefonska številka v slovarju shranjena kot niza, pretvorba v niz pred zapisovanjem ni potrebna.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def shrani_imenik(ime_datoteke, imenik):
    f = open(ime_datoteke, mode='w') # prepisovanje
    for ime, stevilka in imenik.items():
        f.write(ime) 
        f.write(',')
        f.write(stevilka)
        f.write('\n')
    f.close()
\end{lstlisting}
Štiri nize (\texttt{ime}, \texttt{','}, \texttt{stevilka} in \texttt{'$\backslash$n'} bi lahko združili skupaj in metodo \texttt{write} uporabili samo enkrat.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def shrani_imenik(ime_datoteke, imenik):
    f = open(ime_datoteke, mode='w') # prepisovanje
    for ime, stevilka in imenik.items():
        f.write(ime+','+stevilka+'\n')
    f.close()
\end{lstlisting}
Za pisanje pa bi lahko uporabili tudi funkcijo \texttt{print}. Tej moramo spremeniti privzeto ločilo (presledek) v zahtevano ločilo (vejica). Takole:
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def shrani_imenik(ime_datoteke, imenik):
    f = open(ime_datoteke, mode='w') # prepisovanje
    for ime, stevilka in imenik.items():
        print(ime, stevilka, sep=',', file=f)
    f.close()
\end{lstlisting}
\end{resitev}

\section{Kodiranje znakov}

Že na začetku poglavja smo omenili, da vsebino datoteke predstavlja zaporedje števil, ki jih lahko v primeru tekstovnih datotek pretvorimo v neoblikovan tekst oziroma neko zaporedje znakov. Vsak znak je torej shranjen kot neko število. \emph{Kodiranje} določa preslikavo, ki posamezno število oziroma \emph{kodo} preslika v določen znak. Do kode znaka lahko pridemo z uporabo vgrajene funkcije \texttt{ord}, ki ji kot argument podamo en znak:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> ord('a')
97
>>> ord('A')
65
\end{lstlisting}
Preslikavo lahko naredimo tudi v drugo smer (iz kode v znak), in sicer z uporabo funkcije \texttt{chr}, ki ji kot argument podamo kodo znaka:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> chr(97)
'a'
>>> chr(65)
'A'
\end{lstlisting}

Koda posameznega znaka je odvisna od uporabljenega kodiranja, pri čemer obstaja kar nekaj različnih načinov kodiranja. Izkaže se, da so osnovni znaki ne glede na uporabljeno kodiranje zakodirani na enak način (enaka koda predstavlja enak znak). Pri kodiranju teh se namreč uporablja 7-bitni standard ASCII \angl{American Standard Code for Information Interchange}. Posamezen znak je torej predstavljen s 7 biti, kar pomeni, da lahko zakodiramo $2^7=128$ različnih znakov. Pri tem je 32 kod rezerviranih za posebne znake (med te sodi npr. tudi znak za novo vrstico). Torej nam ostane 96 kod, s katerimi moramo predstaviti male črke, velike črke, številke in različna ločila ter simbole. Izkaže se, da teh kod zelo hitro zmanjka in zato služijo zgolj predstavitvi osnovnih znakov in črk angleške abecede. Kaj pa naši šumnik, nemški preglasi in kitajske pismenke? Za predstavitev teh moramo uporabiti razširitve kodiranja ASCII. Omenimo dve razširitvi, ki sta v pogosti uporabi v današnjem času. 

Kodne tabele \angl{code page} kodiranje ASCII razširjajo z dodatnim bitom, kar pomeni, da lahko z njihovo uporabo predstavimo dodatnih 128 znakov. To je sicer dovolj za znake č, ž in š, kaj pa za kitajske pismenke? Dodatnih kod seveda ni dovolj, da bi predstavili še te, poleg njih pa mogoče še črke iz cirilice, korejski hangul in še kaj drugega. Iz tega razloga se v različnih delih sveta uporabljajo različne kodne tabele. Pri nas je npr. v uporabi centralno-evropska kodna tabela \texttt{cp1250}, s katero lahko predstavimo tudi znake č, ž in š. Znak \texttt{č} je v tej kodni tabeli določen s kodo \texttt{232}. V Nemčiji uporabljajo zahodno-evropsko kodno tabelo \texttt{cp1252}, s katero sicer ne moremo predstaviti šumnikov, lahko pa predstavimo preglase. V tej kodni tabeli koda \texttt{232} predstavlja znak \texttt{è}, kar ste mogoče že kdaj opazili, npr. pri predvajanju datoteke s podnapisi, ki jih program za predvajanje filmov poskuša dekodirati z napačnim kodiranjem.

Kljub temu, da se kodne tabele še vedno uporabljajo, je v današnjem času v večinski rabi standard \emph{unicode}, katerega pomemben predstavnik je kodiranje UTF-8. Pri tem je posamezen znak zapisan z minimalno 8 biti. V primeru, da se v našem besedilu pojavijo znaki, ki ne nastopajo v osnovnem ASCII kodiranju (npr. č), se zapis posameznega znaka razširi (V konkretnem primeru na 16-bitni zapis). Prednost tega načina kodiranja je, da lahko datoteke iz različnih delov sveta, ki vsebujejo različne lokalne pisave, dekodiramo z enim samim kodiranjem in uporabniku ni potrebno ročno preklapljati med različnimi načini kodiranja, kot v primeru kodnih tabel.

Zakaj se moramo s kodiranjem znakov ukvarjati v okviru osnov programiranja? Pri branju in pisanju datotek je zaželeno, da izrecno podamo tudi kodiranje, ki ga želimo uporabiti. S tem se namreč izognemo težavam z napačno interpretacijo znakov. Če je nekdo zapisal datoteko z uporabo kodiranja UTF-8, mi pa jo poskusimo odpreti s kodiranjem cp1250, bo prišlo do napake ali pa bodo znaki dekodirani narobe. Če kodiranja ne podamo (kot ga nismo podali v primerih zgoraj), bo uporabljeno privzeto kodiranje našega operacijskega sistema. Poglejmo si še enkrat kaj se skriva za spremenljivko, preko katere odpremo datoteko:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f 
<_io.TextIOWrapper name='stevila.txt' mode='r' encoding='cp65001'>
\end{lstlisting}
Kodiranje \angl{encoding} je v konkretnem primeru nastavljeno na \texttt{'cp65001'}, ki predstavlja nekakšen ekvivalent kodiranja UTF-8 v operacijskem sistemu Windows. Operacijski sistem Windows sicer pogosto uporablja kodiranje cp1250, Linux pa UTF-8. Zmešnjava je torej popolna. To lahko povzroči nemalo težav, zato je pri delu z datotekami pomembno, da vedno podamo način kodiranja. Dogovorimo se, da bomo od zdaj naprej pri delu z datotekami vedno podali način kodiranja, ki naj bo kar UTF-8. 

Kodiranje, ki ga želimo uporabiti pri pisanju ali branju datoteke, navedemo pri odpiranju datoteke s funkcijo \texttt{open} preko izbirnega argumenta \texttt{encoding}. Zapišimo datoteko z uporabo kodiranja UTF-8\footnote{Argument \texttt{encoding} bomo nastavili na vrednost \texttt{'utf8'}, \texttt{'utf-8'}, \texttt{'UTF8'} ali \texttt{'UTF-8'}.}:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open("posebni_znaki.txt", mode='w', encoding="utf8")
>>> f.write("čžš")
3
>>> f.close()
\end{lstlisting}
Zdaj datoteko preberimo z uporabo kodiranja cp1250:
\begin{lstlisting}[language=Python]
>>> f = open("posebni_znaki.txt", encoding="cp1250")
>>> f.read()
'ÄŤĹľĹ'
\end{lstlisting}

Rezultat je seveda napačen. Poskusimo še s pravilnim kodiranjem:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open("posebni_znaki.txt", encoding="utf8")
>>> f.read()
'čžš'
\end{lstlisting}

Izbira ustreznega kodiranja pri delu z datotekami je torej pomembna. Dopolnimo naši funkciji za branje telefonskega imenika iz datoteke in njegovo zapisovanje v datoteko, saj je velika verjetnost, da bodo v imenih naših prijateljev nastopali tudi šumniki.

\begin{zgled}
Napiši funkciji za branje in shranjevanje telefonskega imenika v in iz datoteke, pri čemer je imenik podan kot slovar, v katerem ključi predstavljajo imena oseb, vrednosti pa njihove telefonske številke. Datoteka naj bo zakodirana z uporabo kodiranja UTF-8.
\end{zgled}
\begin{resitev}
Rešitev bo praktično enaka kot v prej, le da bomo pri odpiranju datoteke izbirni argument \texttt{encoding} postavili na vrednost \texttt{'utf8'}.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def shrani_imenik(ime_datoteke, imenik):
    # pri odpiranju datoteke podamo še kodiranje
    f = open(ime_datoteke, mode='w', encoding='utf8')
    for ime, stevilka in imenik.items():
        print(ime, stevilka, sep=',', file=f)
    f.close()

def preberi_imenik(ime_datoteke):
    # pri odpiranju datoteke podamo še kodiranje
    f = open(ime_datoteke, encoding='utf8') 
    imenik = {} # prazen slovar
    for vrstica in f:
        vrstica = vrstica.strip() # odstrani '\n'
        if vrstica: # vrstica ni prazna?
            ime, stevilka = vrstica.split(',') # razpakiraj
            imenik[ime] = stevilka # dodajanje vnosa
    return imenik
\end{lstlisting}
\end{resitev}

\section{Datoteke CSV}

Zapis \texttt{CSV} \angl{comma separated values} predstavlja način zapisovanja podatkov v tekstovne datoteke, pri čemer vsaka vrstica vsebuje svoj zapis (npr. osebo), podatki znotraj posamezne vrstice (npr. ime osebe in telefonska številka) pa so med seboj ločeni z vejicami. Primer datoteke CSV smo v tem poglavju že srečali, in sicer, ko smo v datoteko zapisovali telefonski imenik. Kot ločilo je lahko uporabljeno tudi kaj drugega kot vejica, npr. podpičje ali tabulator. Pomembno je, da je za ločilo uporabljen znak, ki se sicer med podatki nikoli ne pojavi. Če bi npr. datoteka vsebovala decimalna števila zapisana z decimalno piko, bi bila pika zelo slaba izbira za ločilo med podatki znotraj vrstice. Včasih uporabljeno ločilo nakazuje že končnica datoteke. Končnica \texttt{csv} npr. nakazuje na to, da je za ločilo uporabljena vejica \angl{comma}, \texttt{tsv} pa tabulator. Včasiv so datoteke CSV shranjene s končnico \texttt{txt}. V tem primeru je najlažje, če datoteko odpremo z beležnico ali beležnici podobnim orodjem in takoj vidimo kateri znak je uporabljen za ločilo. 

Prednost uporabe datotek CSV je v tem, da jih lahko zelo enostavno razčlenimo \angl{parse} oziroma z drugimi besedami, da lahko podatke iz njih zelo enostavno pridobimo in pretvorimo v obliko, ki bo najustreznejša za nadaljno obdelavo (spomnimo se npr. na omrežja prijateljstev). Kot smo videli v primeru branja telefonskega imenika, smo posamezno vrstico, ki predstavlja en zapis (npr. osebo) zgolj razbili z metodo \texttt{split}. Tako smo prišli do seznama podatkov (npr. imena in telefonske številke), ki pripadajo posameznemu zapisu (npt. osebi). Tudi zapisovanje podatkov datotek CSV je nadvse preprosto, saj moramo med podatke, ki jih zapisujemo zgolj vrniti izbrano ločilo, zapise pa med seboj ločiti z novimi vrsticami. Na zapise lahko torej gledamo tudi kot na vrstice, na podatke znotraj zapisov pa kot na stolpce v tabeli. 

Datoteke CSV se v današnjem času uporabljajo zelo pogosto, saj zagotavljajo kompatibilnost zapisanih podatkov med različnimi orodji. Vse kar moramo za branje teh podatkov in izvedbo nadaljnjih analiz poznati je ločilo, ki loči podatke znotraj zapisa (tega lahko določimo tako, da datoteko odpremo z beležnico) in kodiranje, ki je bilo uporabljeno pri zapisovanju podatkov. V določenih primerih datoteka CSV vsebuje tudi \emph{glavo}, ki podaja pomen posameznega stolpca v datoteki, v določenih primerih pa moramo vnaprej vedeti kaj posamezen stolpcev predstavlja. 

Datoteke CSV lahko enostavno uvozimo v različna orodja za obdelavo podatkov, kot je npr. Excel, lahko pa obdelavo podatkov naredimo kar v jeziku Python. Za shranjevanje in branje datotek CSV obstaja kar nekaj knjižnic (v zadnjem času se za namen obdelave podatkov, ki zajema tudi branje in pisanje datotek CSV uporablja predvsem knjižnica \texttt{pandas}, ki jo bomo še srečali), mi pa bomo branje malo kompleksnejše datoteke CSV izvedli kar z osnovnimi konstrukti jezika Python, podobno kot smo to naredili že s telefonskim imenikom. Poglejmo si naslednji primer. 

Najprej bomo pridobili testne podatke, v obliki datoteke CSV.
\begin{zgled}
Na spletni strani Statističnega urada Republike Slovenije (\url{https://www.stat.si/}) poišči bazo podatkov SiStat, v njej pa podatke o povprečnih mesečnih bruto in neto plačah pri pravnih osebah javnega in zasebnega sektorja. Te izvozi v obliki CSV, pri čemer želimo imeti ločene podatke za javni in zasebni sektor ter za bruto in neto plače, zanimajo pa nas plače za posamezen mesec.
\end{zgled}

\begin{resitev}
Na začetni strani poiščemo povezavo na podatkovno bazo SiStat\\ (\url{https://pxweb.stat.si/SiStat}). Sledimo povezavam: \emph{Demografsko in socialno področje} $\rightarrow$ \emph{Trg dela} $\rightarrow$ \emph{Plače in stroški dela} $\rightarrow$ \emph{Povprečne mesečne plače} $\rightarrow$ \emph{Povprečne mesečne bruto in neto plače pri pravnih osebah javnega in zasebnega sektorja, Slovenija, mesečno}. Tu si izberemo mesce, ki jih želimo izvoziti, sektorja in bruto ter neto plače. Pod \emph{Meritve} si izberemo še \emph{Plače za mesec}. Spodaj si izberemo eno izmed oblik CSV za izvoz in podatke izvozimo. Datoteko preimenujemo v \texttt{place.csv}. Primer tako izvožene datoteke je na voljo na \href{https://raw.githubusercontent.com/mmoskon/OP_skripta/master/resitve/place.csv}{povezavi}. 
\end{resitev}

Zdaj bomo poskusili podatke uvoziti v Python in izračunali povprečje razpoložljivih mesečnih plač v javnem in v zasebnem sektorju.
\begin{zgled}
Napiši funkcijo \texttt{uvozi\_place}, za uvoz podatkov o mesečnih plačah. Funkcija naj kot argument sprejme ime datoteke s podatki in slovar, ki kot ključ vsebuje naziv sektorja, kot vrednost pa nov slovar. V tem slovarju naj bodo ključi nizi \texttt{'mesec'}, \texttt{'bruto'} in \texttt{'neto'}, za katerimi so seznami, ki predstavljajo mesece, bruto zneske in neto zneske. Seznami naj imajo na enakem indeksu podatek za enak mesec.
\end{zgled}
\begin{resitev}
Najprej moramo podrobneje pogledati kako je datoteka strukturirana. V ta namen jo odpremo z beležnico ali podobnim orodjem (ne z orodjem Excel). Če je odpremo z orodjem \emph{Notepad++}, lahko enostavno preverimo kako je datoteka zakodirana. Če določeni znaki niso berljivi, postanejo berljivi, ko kodiranje nastavimo na \emph{cp1250} (\emph{Encoding} $\rightarrow$ \emph{Character Sets} $\rightarrow$ \emph{Central European} $\rightarrow$ \emph{Windows-1250}). To kodiranje bomo torej uporabili pri odpiranju datoteke:
\begin{lstlisting}[language=Python, showstringspaces=false]
f = open("place.csv", encoding="cp1250")
\end{lstlisting}

Zdaj se lotimo vsebine datoteke. Takoj vidimo, da prve tri vrstice ne vsebujejo podatkov. Te bomo torej preskočili. Lahko kar tako, da jih preberemo:
\begin{lstlisting}[language=Python, showstringspaces=false]
f.readline()
f.readline()
f.readline()
\end{lstlisting}

Ostale vrstice bomo shranjevali v slovar seznamov, ki ga bomo lahko kasneje uporabili za analizo mesečnih plač. Najprej si pripravimo prazen slovar:
\begin{lstlisting}[language=Python, showstringspaces=false]
place = {}
\end{lstlisting}

Zdaj se bomo z zanko \texttt{for} sprehodili čez preostanek datoteke. Posamezno vrstico bomo najprej oklestili znaka za novo vrstico, potem pa razbili glede na uporabljeno ločilo. V beležnici ali orodju Notepad++ vidimo, da je to tabulator (\texttt{$\backslash$t}).
\begin{lstlisting}[language=Python, showstringspaces=false]
seznam = vrstica.strip().split("\t")
\end{lstlisting}
Tako pridobljen seznam bo sestavljen iz štirih podatkov: podatka o mesecu, sektorju, bruto plači in neto plači. Razpakirajmo ga:
\begin{lstlisting}[language=Python, showstringspaces=false]
mesec = seznam[0]
sektor = seznam[1]
bruto = seznam[2]
neto = seznam[3]
\end{lstlisting}
Šlo bi tudi hitreje:
\begin{lstlisting}[language=Python, showstringspaces=false]
mesec, sektor, bruto, neto = seznam
\end{lstlisting}
Podatku o mesecu in sektorju lahko pred nadaljnjo obdelavo odstranimo dvojne navednice:
\begin{lstlisting}[language=Python, showstringspaces=false]
mesec = mesec.replace('"','')
sektor = sektor.replace('"','')
\end{lstlisting}
Zneske bomo pretvorili v števila tipa \texttt{float}:
\begin{lstlisting}[language=Python, showstringspaces=false]
bruto = float(bruto)
neto = float(neto)
\end{lstlisting}

Potem bomo preverili, če je sektor že med ključi slovarja plač. Če ga še ni, ga bomo dodali in naj vezali začetni slovar za shranjevanje podatkov \texttt{{'mesec':[], 'neto':[], 'bruto':[]}}. Takole.
\begin{lstlisting}[language=Python, showstringspaces=false]
if sektor not in place: # če sektorja še ni
    place[sektor] = {'mesec':[], 
                     'neto':[], 
                     'bruto':[]}
\end{lstlisting}

Zdaj v sezname, ki pripadajo trenutnemu sektorju dodamo trenutne podatke o mesecu, bruto in neto plači:
\begin{lstlisting}[language=Python, showstringspaces=false]
place[sektor]['mesec'].append(mesec)
place[sektor]['neto'].append(neto)
place[sektor]['bruto'].append(bruto)
\end{lstlisting}

Celotno rešitev zapisano v obliki funkcije predstavlja spodnja koda:
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def uvozi_place(ime_datoteke):
    
    # datoteka je zakodirana s cp1250
    f = open(ime_datoteke, encoding='cp1250')
    
    # prve tri vrstice vržemo proč
    f.readline()
    f.readline()
    f.readline()
    
    # prazen slovar
    place = {}
    
    for vrstica in f:
        # razbijmo vrstico na seznam s podatki
        seznam = vrstica.strip().split("\t")
        # razpakirajmo seznam
        mesec, sektor, bruto, neto = seznam
    
        # odstranimo dvojne navednice
        mesec = mesec.replace('"','')
        sektor = sektor.replace('"','')
    
        # zneske pretvorimo v števila
        bruto = float(bruto)
        neto = float(neto)

        if sektor not in place: # če sektorja še ni
            place[sektor] = {'mesec':[], 'neto':[], 'bruto':[]}

        # dodamo podatke v ustrezen slovar
        place[sektor]['mesec'].append(mesec)
        place[sektor]['neto'].append(neto)
        place[sektor]['bruto'].append(bruto)
        
    # podatki so zdaj pripravljeni
    return place
\end{lstlisting}
\end{resitev}

Podatke lahko zdaj preberemo in obdelamo. Lahko npr. izračunamo povprečje mesečnih bruto plač v javnem in v zasebnem sektorju:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> place = uvozi_place('place.csv')
>>> ZJ = place['Javni sektor']['neto']
>>> ZZ = place['Zasebni sektor']['neto']
>>> avg_javni = sum(ZJ)/len(ZJ)
>>> avg_zasebni = sum(ZZ)/len(ZZ)
>>> avg_javni
1886.8506756756758
>>> avg_zasebni
1502.0971621621622
\end{lstlisting}

Vidimo torej, da so plače v javnem sektorju precej višje. Z analizami bi lahko nadaljevali. Lahko bi npr. poiskali mesec, ko je bila plača najvišja, pogledali kakšni so trendi itd. Pred podrobnejšo obdelavo pa vselej pomaga, če si podatke prej narišemo. In ravno to bomo naredili v naslednjem poglavju.
