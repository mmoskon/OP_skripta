\chapter{Delo z datotekami}

\section{Zakaj pisati v datoteke in brati iz njih?}

Programi, ki smo jih napisali do zdaj, so podatke hranili le za čas njihovega izvajanja v t.i. \emph{delovnem pomnilniku}. Ko se je nek program končal, so ti podatki izginili in ko smo program ponovno zagnali, smo morali te podatke ponovno zgenerirati, npr. tako, da smo jih prebrali od uporabnika (če smo bolj natančni, so podatki izginili, ko smo resetirali okolje IDLE npr. z zagonom drugega ali istega programa). Ko smo torej dopolnjevali telefonski imenik z novimi vnosi, se je imenik ob končanju programa izbrisal in dodani vnosi so izginili. To običajno predstavlja problem zaradi več razlogov:
\begin{itemize}
    \item Ko se program neha izvajati, podatki izginejo. V primeru imenika se ta torej ob vsakem ponovnem zagonu programa resetira na začetno, npr. prazno, vsebino.
    \item Nimamo varnostnih kopij podatkov. Če se npr. telefon, ki uporablja naš imenik, ugasne, moramo celotno vsebino imenika ustvariti od začetka.
    \item Podatkov, ki smo jih ustvarili v enem programu, ne moremo oziroma težko uporabljamo v drugih programih. 
\end{itemize}
Na srečo lahko podatke v svojih programih iz delovnega pomnilnika oziroma iz vsebine spremenljivk, kadarkoli shranimo v t.i. \emph{trajni pomnilnik} oziroma po domače na \emph{disk}. S tem omogočimo njihovo trajno hrambo, kar pomeni, da lahko do teh podatkov pridemo tudi po zaključku izvajanja programa, na disku podatki ostanejo tudi po izklopu računalnika, do njih pa lahko pridemo tudi iz drugih programov. 

Kako pa podatke shranimo na disk? Podobno, kot smo do zdaj na disk shranjevali naše programe v obliki datotek s končnico \texttt{py}, lahko v (druge) datoteke shranjujemo tudi podatke, s katerimi delamo. 

Tako shranjene datoteke lahko kasneje v svojih programih preberemo in s tem \emph{obnovimo} stanje svojega delovnega pomnilnika oziroma določimo vrednosti spremenljivk na podlagi vsebine datoteke. Dodatna prednost branja podatkov iz datotek je to, da se nam zdaj ni treba več zanašati na vnos podatkov s strani uporabnika, ampak lahko podatke, ki jih želimo obdelati, v svoje programe preberemo kar iz datotek. Če bi npr. želeli pregledati podatke o povprečnih mesečnih plačah v Sloveniji, najpogostejših imenih ali inflaciji, bi te lahko prenesli iz spletne strani Statističnega urada republike Slovenije (SURS, \url{https://www.stat.si/statweb}), jih v svojem programu prebrali in ustrezno obdelali. V tem poglavju si bomo pogledali kako podatke iz datoteke prebrati in kako v datoteko podatke zapisati.

\section{Kaj je datoteka?}

Datoteke predstavljajo osnovni način zapisovanja podatkov na disku (ali na kakšnem drugem mediju). Datoteke predstavljajo trajno hrambo podatkov, omogočajo prenašanje podatkov med različnimi uporabniki in lahko vsebujejo različne tipe podatkov od teksta, besedil, slik in filmov, do datotek, ki jih operacijskih sistem uporablja za svoje delovanje. Ponavadi tip datoteke označuje njena končnica. Programi v Pythonu na primer uporabljajo končnico \texttt{py}, slike pa končnice kot \texttt{jpg}, \texttt{png} ali \texttt{gif}. 

V grobem lahko datoteke ločimo v dve skupini, in sicer na \emph{tekstovne datoteke} in \emph{binarne datoteke}. V obeh primerih vsebino datoteke predstavlja zaporedje števil, ki si jih lahko v primeru tekstovnih datotek interpretiramo kot zaporedje znakov oziroma nek (neoblikovan) tekst. Primer tekstovne datoteke je recimo datoteka s končnico \texttt{py} ali datoteka s končnico \texttt{txt}. Za tekstovne datoteke velja, da jih lahko odpremo z beležnico ali beležnici podobnimi orodji (npr. \emph{Notepad++}) in je njihova vsebina bolj ali manj berljiva. Kaj pa binarne datoteke? V skupino binarnih datotek uvrščamo vse ostalo, npr. slike, filme in oblikovana besedila. Če poskusite z beležnico odpreti datoteko s končnico \texttt{docx} (besedilo oblikovano z orodjem Microsoft Word), boste hitro videli, da to ni tekstovna datoteka. Tako kot pri tekstovnih datotekah je zapis s števili uporabljen tudi pri binarnih datotekah. Različna je le interpretacija teh števil. Medtem, ko lahko vsebino tekstovnih datotek orodja, kot je beležnica, enostavno dekodirajo kot zaporedje znakov, potrebujemo za binarne datoteke druga orodja oziroma programe, ki znajo njihovo vsebino dekodirati, glede na tip zapisa. Ena orodja pretvarjajo številke v slike, druga v filme, tretja v oblikovano besedilo. Katero orodje bo posamezno datoteko ob dvojnem kliku nanju odprlo, določa njena končnica. Če se končnica datoteke ne ujema z njeno vsebino, bo orodje vrnilo napako ali pa v najboljšem primeru prikazalo nekaj nenavadnega, podobno kot če datoteko s končnico \texttt{docx} odpremo z beležnico. 

\section{Tekstovne datoteke}
Tekstovne datoteke torej vsebujejo neoblikovan tekst, ki lahko predstavlja na primer neko besedilo, program v Pythonu ali pa podatke, ki smo jih zgenerirali tekom delovanja našega programa. V okviru spoznavanja osnov programiranja se bomo neposredno ukvarjali zgolj s tekstovnimi datotekami. 

\section{Odpiranje datoteke}

Če želimo neko datoteko v našem programu prebrati ali vanjo pisati, jo moramo najprej seveda odpreti. To lahko naredimo z vgrajeno funkcijo \texttt{open}, ki ji bomo za začetek podali zgolj ime datoteke, do katere želimo dostopati. Naredimo tekstovno datoteko \texttt{stevila.txt} s sledečo vsebino\footnote{Datoteko naredimo tako, da odpremo beležnico, vpišemo vsebino datoteke in datoteko shranimo.}:
\begin{lstlisting}[showstringspaces=false,numbers=left]
4
5.6
2
100
15
\end{lstlisting}
Datoteko shranimo v mapo kamor pač najpogosteje shranjujemo svoje datoteke. Zdaj jo poskusimo odpreti v Pythonu:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> open('stevila.txt')
FileNotFoundError: [Errno 2] No such file or directory: 
'stevila.txt'
\end{lstlisting}
Python pravi, da datoteke ne najde, čeprav smo jo pravkar ustvarili. Problem je v tem, da Python datoteko išče v svoji trenutni \emph{delovni mapi}, ki očitno ni enaka tisti, kamor smo mi shranili svojo datoteko\footnote{Do trenutne delovne mape lahko pridemo preko funkcije \texttt{getcwd} iz vgrajenega modula \texttt{os}.}. Problem bi lahko rešili na dva načina.

Prvi način je, da Pythonu podamo \emph{absolutno pot} do lokacije datoteke. Pythonu smo do datoteke v gornjem primeru podali t.i. \emph{relativno pot}, kar pomeni, da bo datoteko iskal relativno glede na trenutno delovno mapo. Če je njegova delovna mapa npr. \texttt{C:$\backslash$Windows$\backslash$system32}, pričakuje, da se datoteka nahaja tu. Lahko pa Pythonu podamo celotno oziroma \texttt{absolutno} pot. Če smo datoteko npr. shranili v mapo \texttt{C:$\backslash$Programiranje}, jo zdaj lahko odpremo takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> open('C:\\Programiranje\\stevila.txt')
<_io.TextIOWrapper name='C:\\Programiranje\\stevila.txt' mode='r'
encoding='cp65001'>
\end{lstlisting}
Tokrat smo datoteko le našli. Mimogrede, zakaj je bilo pri podajanju poti potrebno podati dve poševnici (\texttt{$\backslash$}). Kot smo videli v prejšnjem poglavju, poševnico Python obravnava kot začetek posebnega znaka. Z njo lahko npr. zapišemo tabulator (\texttt{$\backslash$t}) ali pa znak za novo vrstico (\texttt{$\backslash$n}). Če bi radi zapisali poševnico pa v niz enostavno vpišemo dve poševnici (\texttt{$\backslash\backslash$}).

Drugi način, ki je nekoliko enostavnejši in bolj pogost, je, da pač spremenimo svojo delovno mapo in potem do datoteke podamo relativno pot. To ponavadi v praksi pomeni, da podamo samo ime datoteke (kot v primeru, ko je Python javil napako). Kako pa spremenimo trenutno delovno mapo? Načeloma nam za to ni potrebno posebej skrbeti, saj bo IDLE ob zagonu programa Pythonovo delovno mapo avtomatsko zamenjal za tisto, v kateri se program nahaja. Če bomo datoteko odprli iz programa, ki se bo nahajal v isti mapi kot datoteka, lahko torej podamo zgolj njeno ime. Če torej naredimo program \texttt{branje.py} in ga shranimo v mapo, v katero smo prej shranili \texttt{stevila.txt}, lahko iz njega datoteko odpremo takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
open('stevila.txt')
\end{lstlisting}

\section{Branje datoteke}
Datoteko smo torej uspešno odprli, zdaj pa jo bomo poskusili prebrati. Dostopanje do datoteke lahko izvedemo preko objekta, ki ga vrne funkcija \texttt{read}. Če hočemo datoteko prebrati, moramo ta objekt torej shraniti v neko spremenljivko, preko katere ga bomo lahko kasneje še poklicali. Takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
f = open('stevila.txt')
\end{lstlisting}
Do metod za delo z datoteko lahko zdaj dostopamo preko spremenljivke \texttt{f}. Prvi način za branje datoteke je uporaba metode \texttt{read}, ki prebere datoteko od začetka do konca in vrne niz z njeno vsebino. V našem primeru bo rezultat sledeč:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.read()
'4\n5.6\n2\n100\n15'
\end{lstlisting}
To je torej zapisano v datoteki. Niz vsebuje števila, ki so med seboj ločena z znaki za novo vrstico \texttt{$\backslash$n}. Če bi želeli imeti lepši izpis, bi stvar izpisali s funkcijo \texttt{print}, ki znake za novo vrstico izpiše kot nove vrstice. Poskusimo:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> print(f.read())

\end{lstlisting}
Zakaj se tokrat ni nič izpisalo? Poleg tega, da lahko preko spremenljivke \texttt{f} dostopamo do datoteke, le-ta beleži, do kje je bila datoteka že prebrana. Datoteko lahko namreč beremo tudi po kosih (npr. vrstico po vrstico), pri čemer nočemo, da bi vedno brali npr. samo prvo vrstico, ampak bi radi slej ko prej prišli do konca datoteke. Ker smo našo datoteko že prebrali, jo moramo za ponovno branje ponovno odpreti. Ker je trenutna delovna mapa zdaj že enaka mapi, kjer se nahaja naša datoteka, lahko odpiranje tokrat naredimo kar iz ukazne vrstice:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> print(f.read())
4
5.6
2
100
15
\end{lstlisting}

Že prej smo omenili, da lahko datoteko beremo tudi po vrsticah. Lahko npr. uporabimo metodo \texttt{readline}:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.readline()
''
\end{lstlisting}
Tole spet ne deluje, ker se nahajamo na koncu datoteke. Ponovno jo odprimo in preberimo prvo vrstico:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f.readline()
'4\n'
\end{lstlisting}
Branje po vrsticah lahko izvedemo tudi z zanko \texttt{for}. Takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> for vrstica in f:
	print(vrstica)
5.6

2

100

15
\end{lstlisting}
Prva vrstica seveda manjka, ker smo jo prej prebrali že z metodo \texttt{readline}. Zakaj se v izpisu pojavlja prazna vrstica? En znak za prazno vrstico je prispevala funkcija \texttt{print}, drugega pa smo dobili iz prebrane datoteke. Znake za prazno vrstico lahko iz niza, ki predstavlja trenutno prebrano vrstico, odstranimo z metodo \texttt{strip}, ki odstrani prazen prostor pred začetkom in po koncu \emph{prave} vsebine niza:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> for vrstica in f:
	print(vrstica.strip())
4
5.6
2
100
15
\end{lstlisting}

Zadnja metoda, preko katere lahko preberemo datoteko, je metoda \texttt{readline}, ki podobno kot metoda \texttt{read} prebere celo datoteko, jo razbije po vrsticah in te zapiše v seznam.
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f.readlines()
['4\n', '5.6\n', '2\n', '100\n', '15']
\end{lstlisting}

Datoteko lahko torej preberemo na več različnih načinov, pri čemer je vsem skupno to, da vsebino datoteke preberejo kot niz. Če bi želeli vsebino obravnavati kot kaj drugega, jo bomo morali prej ustrezno obdelati (podobno kot moramo npr. v ustrezen podatkovni tip pretvoriti rezultat funkcije \texttt{input}).

Poskusimo branje na zgledu.
\begin{zgled}
Napiši funkcijo \texttt{povprecje}, ki kot argument prejme niz z imenom datoteke in izračuna povprečje števil, ki so shranjena v datoteki. Predpostavljaš lahko, da je vsako število v datoteki zapisano v svoji vrstici. V primeru, da je datoteka prazna, naj funkcija vrne število 0.
\end{zgled}
\begin{resitev}
Funkcijo lahko napišemo s sprehodom čez vrstice, pri čemer vsebino vsake vrstice prištevamo skupni vsoti, ki jo na koncu delimo s številom vrstic. Vsebino vrstice moramo prej seveda očistiti (metoda \texttt{strip}) in pretvoriti v število (funkcija \texttt{float}). 
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def povprecje(ime_datoteke):
    f = open(ime_datoteke)
    s = 0
    n = 0
    for vrstica in f:
        stevilo = float(vrstica.strip())
        s += stevilo
        n += 1
    if n > 0:
        return s/n
    else:
        return 0
\end{lstlisting}
\end{resitev}

Kaj pa če bi imeli v eni vrstici več števil? V tem primeru je potrebno vrstico več števil prej še razbiti na posamezna števila. To lahko naredimo z uporabo metode \texttt{split}, ki jo pokličemo nad posamezno vrstico in ji kot argument podamo ustrezno ločilo.

\begin{zgled}
Napiši funkcijo \texttt{povprecje}, ki kot argument prejme niz z imenom datoteke in izračuna povprečje števil, ki so shranjena v datoteki. Predpostavljaš lahko, da je v posamezni vrstici lahko zapisano več števil, ki so med seboj ločena z vejicami.
\end{zgled}
\begin{resitev}
Tokrat bomo posamezno vrstico z metodo \texttt{split} razbili na seznam, čez katerega se bomo sprehodili z ugnezdeno zanko \texttt{for}. Še vedno pa moramo posamezen element tega seznama pred prištevanjem skupni vsoti pretvoriti v število.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def povprecje(ime_datoteke):
    f = open(ime_datoteke)
    s = 0
    n = 0
    for vrstica in f:
        vrstica = vrstica.strip()
        for element in vrstica.split(","):
            stevilo = float(element)
            s += stevilo    
            n += 1
    if n > 0:
        return s/n
    else:
        return 0
\end{lstlisting}
\end{resitev}

Poskusimo rešiti še težave, ki smo jih imeli s telefonskim imenikom (pa tega nismo vedeli).
\begin{zgled}
Napiši funkcijo \texttt{preberi\_imenik}, ki kot argument prejme niz z imenom datoteke, ki vsebuje varnostno kopijo telefonskega imenika. Funkcija naj datoteko prebere in vrne slovar, v katerem so ključi imena oseb, vrednosti pa njihove telefonske številke zapisane kot nizi. Predpostavljaš lahko, da so podatki v datoteki zapisani v obliki \texttt{CSV}\footnote{CSV zapis \angl{comma separated values} predstavlja način zapisovanja podatkov v tekstovne datoteke, pri čemer vsaka vrstica vsebuje svoj zapis (npr. osebo), podatki znotraj posamezne vrstice (npr. ime osebe in telefonska številka) pa so med seboj ločeni z vejicami ali kakšnim drugim ločilom, kot je npr. podpičje ali tabulator. Pomembno je, da je za ločilo uporabljen znak, ki se sicer med podatki nikoli ne pojavi. Če bi npr. datoteka vsebovala decimalna števila ločena s piko, bi bila pika zelo slaba izbira za ločilo med podatki znotraj vrstice.}, pri čemer posamezna vrstica vsebuje ime osebe, ki je od telefonske številke osebe ločeno z vejico.
\end{zgled}
\begin{resitev}
Podobno kot v prejšnjem zgledu bomo s posamezno vrstico naredili sledeče:
\begin{itemize}
    \item odstranili bomo znak za novo vrstico z metodo \texttt{strip};
    \item vrstico bomo razbili na seznam nizov glede na uporabljeno ločilo (\texttt{','}) z metodo \texttt{split};
    \item seznam nizov bomo razpakirali in uporabili kot veleva navodilo naloge.
\end{itemize}

\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def preberi_imenik(ime_datoteke):
    f = open(ime_datoteke)
    imenik = {} # prazen slovar
    for vrstica in f:
        vrstica = vrstica.strip() # odstrani '\n'
        seznam = vrstica.split(',')
        ime = seznam[0]
        stevilka = seznam[1]
        imenik[ime] = stevilka # dodajanje vnosa
    return imenik
\end{lstlisting}
Funkcijo bi lahko še nekoliko izboljšali. Podobno, kot lahko razpakiramo terke, lahko razpakiramo tudi sezname. Torej lahko spremenljivkama \texttt{ime} in \texttt{stevilka} vrednosti priredimo kar v eni vrstici:
\begin{lstlisting}[language=Python, showstringspaces=false]
ime, stevilka = vrstica.split(',')
\end{lstlisting}
Če želimo, da funkcija deluje, tudi v primeru, ko datoteka vsebuje prazne vrstice, moramo pred obdelavo posamezne vrstice preveriti, če ta slučajno ni prazna. Po odstranjevanju znaka za novo vrstico torej preverimo neenakost s praznim nizom:
\begin{lstlisting}[language=Python, showstringspaces=false]
if vrstica != '':
\end{lstlisting}
To lahko krajše zapišemo kar takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
if vrstica:
\end{lstlisting}
Zapišimo celotno rešitev:
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def preberi_imenik(ime_datoteke):
    f = open(ime_datoteke)
    imenik = {} # prazen slovar
    for vrstica in f:
        vrstica = vrstica.strip() # odstrani '\n'
        if vrstica: # vrstica ni prazna?
            ime, stevilka = vrstica.split(',') # razpakiraj
            imenik[ime] = stevilka # dodajanje vnosa
    return imenik
\end{lstlisting}
\end{resitev}

\section{Pisanje v datoteko}

Pisanje v datoteko lahko izvedemo z metodo \texttt{write}, ki ji kot argument podamo niz, ki ga želimo v datoteko zapisati. Poskusimo:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f.write(6)
TypeError: write() argument must be str, not int
\end{lstlisting}
Ravnokar smo rekli, da moramo metodi \texttt{write} podati \textbf{niz}, ki ga želimo zapisati. Če hočemo torej v datoteko zapisati število, ga moramo prej pretvoriti v niz s funkcijo \texttt{str}. Poskusimo še enkrat: 
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f.write('6')
io.UnsupportedOperation: not writable
\end{lstlisting}
Tokrat smo dobili drugo napako. Vidimo, da pisanje ni mogoče, ker smo datoteko odprli za branje. Več informacij o odprti datoteki, lahko izvemo preko spremenljivke, v katero smo datoteko odprli:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f
<_io.TextIOWrapper name='stevila.txt' mode='r' encoding='cp65001'>
\end{lstlisting}
Iz izpisa vidimo, da smo odprli datoteko z imenom \texttt{'stevila.txt'} (kar že vemo) in da je \texttt{mode} oziroma način odpiranja datoteke enak vrednosti \texttt{'r'}, ki se nanaša na branje oziroma \emph{read}. Način odpiranja datoteke lahko funkciji \texttt{open} nastavimo z izbirnim argumentom \texttt{mode}, ki je privzeto enak vrednosti \texttt{'r'}. Če argumenta ne nastavimo, bomo torej datoteko odprli za branje. Pogosto uporabljena načina odpiranja datoteke sta še \texttt{'w'} oziroma pisanje \angl{write} in \texttt{'a'} dodajanje \angl{append}. Pisanju bi lahko, če bi bili nekoliko bolj natančni, rekli tudi prepisovanje, saj bomo s takim načinom pisanja obstoječo datoteko prepisali. Dodajanju bi v podobnem kontekstu lahko rekli dopisovanje, saj bomo obstoječi datoteki vsebino dodajali (na koncu obstoječe vsebine). Pri obeh načinih pa zdaj napake, če datoteka s podanim imenom ne bo obstajala, ne bomo dobili, ampak bo Python to datoteko pač ustvaril. Poskusimo zdaj v datoteko \texttt{'stevila.txt'} zapisati par stevil. Najprej jo odpremo za pisanje:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt', mode = 'w')
\end{lstlisting}
Zdaj pa pišimo:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.write('1')
1
>>> f.write('2')
1
>>> f.write('3')
1
>>> f.write('45')
2
\end{lstlisting}
Vsakič, ko pokličemo metodo \texttt{'write'} ta vrne število znakov, ki smo jih zapisovali. Ko zdaj datoteko \texttt{stevila.txt} odpremo z beležnico (ali beležnici podobnim orodjem), vidimo, da je ta prazna. Zakaj? Pravilo lepega dela z datotekami je, da jih po vsakem odpiranju tudi zapremo za kar lahko uporabimo metodo \texttt{close}. Pri branju to ni nujno potrebno, saj se bo datoteka zaprla avtomatsko, ko bo iz našega imenskega prostora izginila spremenljivka, preko katere smo datoteko brali (najkasneje, ko bomo resetirali okolje IDLE). Pri pisanju pa se lahko zgodi, da bo vsebina datoteke brez eksplicitnega zapiranja datoteke ostala prazna. Ker je pisanje v datoteko počasna operacija, Python, kot smo že navajeni, to v določeni meri optimizira oziroma pohitri. Ko od njega zahtevamo pisanje v datoteko, namreč raje piše v medpomnilnik \angl{buffer}, katerega vsebino bo v dejansko datoteko Python zapisal bodisi takrat, ko se bo nabralo malo več podatkov, da se mu bo splačalo to zapisati v datoteko, ali pa takrat, ko bomo datoteko zaprli, saj s tem povemo, da vanjo ne bomo več pisali. Če želimo, da se naša števila v datoteko zagotvo zapišejo, jo moramo torej zapreti:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.close()
\end{lstlisting}
Ko zdaj odpremo datoteko, vidimo, da se je prejšnja vsebina datoteke prepisala -- seveda, saj smo datoteko odprli za prepisovanje. V njej vidimo sledečo vsebino:
\begin{lstlisting}[showstringspaces=false,numbers=left]
12345
\end{lstlisting}
To ni tisto kar smo hoteli? Mogoče ne, je pa to tisto, kar smo zahtevali. Metoda \texttt{write} namreč v datoteko zapiše točno tisto, kar od nje zahtevamo. Če bi želeli števila zapisati vsako v svojo vrstico, bi morali zraven vsakega števila zapisati tudi znak za novo vrstico (\texttt{$\backslash$n}). Takole:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.write('1')
ValueError: I/O operation on closed file.
\end{lstlisting}
Ker smo datoteko zaprli, zdaj vanjo ne moremo več pisati. Pred ponovnim pisanjem, jo moramo torej spet odpreti:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt', mode='w')
>>> f.write('1\n')
2
>>> f.write('2\n')
2
>>> f.write('3\n')
2
>>> f.write('45\n')
3
\end{lstlisting}
Datoteko moramo na koncu seveda spet zapreti
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f.close()
\end{lstlisting}
Zdaj je njena vsebina sledeča:
\begin{lstlisting}[showstringspaces=false,numbers=left,showlines=true]
1
2
3
45

\end{lstlisting}
Datoteka se konča s prazno vrstico, v katero smo skočili za nizom \texttt{45}. Dodajmo v datoteko še par števil. Če želimo v datoteko novo vsebino dodajati k obstoječi vsebini, jo moramo odpreti za dopisovanje (\texttt{mode='a'}).
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt', mode='a')
>>> f.write('55\n')
3
>>> f.write('133\n')
4
>>> f.write('-6.98\n')
6
>>> f.close()
\end{lstlisting}
Ko datoteko ponovno odpremo z beležnico, vidimo, da smo v njej dobili tri nove vrstice:
\begin{lstlisting}[showstringspaces=false,numbers=left,showlines=true]
1
2
3
45
55
133
-6.98

\end{lstlisting}

Povadimo pisanje še na zgledu.
\begin{zgled}
Napiši funkcijo \texttt{nakljucna}, ki kot argument prejme niz z imenom datoteke in celo število, ki podaja število naključnih števil, ki naj jih funkcija zapiše v datoteko s podanim imenim. Funkcija naj v vsako vrstico v datoteki zapiše največ 10 naključnih celih števil iz intervala od 1 do 100.
\end{zgled}
\begin{resitev}
Naključna števila bomo generirali z uporabo funkcije \texttt{randint} modula \texttt{random}. V datoteko bomo pisali po eno število naenkrat. Po vsakem pisanju lahko zapišemo tudi presledek, na vsakih 10 pisanj pa bomo zapisali znak za novo vrstico.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
# uvazanje vedno delamo izven funkcij
from random import randint

def nakljucna(ime_datoteke, n):
    f = open(ime_datoteke, mode='w') # odpri za prepisovanje
    for i in range(1,n+1): # zanko ponovimo n-krat
        st = randint(1,100) # nakljucno stevilo od 1 do 100
        f.write(str(st)) # stevilo moramo pretvoriti v niz
        if i % 10 == 0: # ali je cas za novo vrstico
            f.write('\n')
        else:
            f.write(' ')
    f.close()
\end{lstlisting}
\end{resitev}

Metoda \texttt{write} torej v datoteko zapiše točno tisto, kar ji podamo, vedno pa ji moramo podati točno en podatek tipa \texttt{str}. Če bi želeli naenkrat zapisati več podatkov, jih moramo torej pred tem sami združiti. V določenih primerih bi bilo veliko bolj priročno, če bi lahko v datoteko pisali na enak način, kot smo stvari izpisovali na zaslon, tj. s funkcijo \texttt{print}. Ta sprejema vrednosti poljubnega tipa, poleg tega pa ji lahko podamo več vrednosti, ki jih bo med sabo združila (privzeto z ločilom \texttt{' '}). Izkaže se, da lahko za pisanje v datoteke uporabimo tudi funkcijo \texttt{print}. Pri tej moramo opcijskemu argumentu z imenom \texttt{file} prirediti spremenljivko, v katero smo datoteko odprli\footnote{Opcijski argument \texttt{file} funkcije \texttt{print} je privzeto postavljen na vrednost \texttt{sys.stdout}, kar pomeni, da pišemo na standardni izhod -- v našem primeru je to konzola okolja IDLE.} Poskusimo na prejšnjem zgledu.
\begin{zgled}
Napiši funkcijo \texttt{nakljucna}, ki kot argument prejme niz z imenom datoteke in celo število, ki podaja število naključnih števil, ki naj jih funkcija zapiše v datoteko s podanim imenim. Funkcija naj v vsako vrstico v datoteki zapiše največ 10 naključnih celih števil iz intervala od 1 do 100. Za pisanje v datoteko uporabi funkcijo \texttt{print}.
\end{zgled}
\begin{resitev}
Rešitev je zelo podobna kot prej, le da nam tokrat števil ni potrebno pretvarjati v nize, funkcija \texttt{print} pa tudi sama poskrbi za pisanje presledkov in novih vrstic (le pravilno jo moramo poklicati).
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
# uvazanje vedno delamo izven funkcij
from random import randint

def nakljucna(ime_datoteke, n):
    f = open(ime_datoteke, mode='w') # odpri za prepisovanje
    for i in range(1,n+1): # zanko ponovimo n-krat
        st = randint(1,100) # nakljucno stevilo od 1 do 100
        if i % 10 == 0: # ali je cas za novo vrstico
            print(st, file=f) # nova vrstica
        else:
            print(st, end=' ', file=f) # presledek 
    f.close()
\end{lstlisting}
\end{resitev}

Za konec dopolnimo še zgled s telefonskim imenikom.
\begin{zgled}
Napiši funkcijo \texttt{shrani\_imenik}, ki kot argument prejme niz z imenom datoteke, ki naj vsebuje varnostno kopijo telefonskega imenika in slovar, v katerem so ključi imena oseb, vrednosti pa njihove telefonske številke. Funkcija imenik zapiše v datoteko s podanim imenom, in sicer tako, da vsaka vrstica vsebuje podatke o eni osebi, pri čemer je ime od telefonske številke ločeno z vejico, tako da bo izhod funkcije kompatibilen s funkcijo \texttt{preberi\_imenik}.
\end{zgled}
\begin{resitev}
V funkciji se bomo sprehodili čez cel imenik in v vsako vrstico zapisali ime in telefonsko številko. Takole:
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def shrani_imenik(ime_datoteke, imenik):
    f = open(ime_datoteke, mode='w') # prepisovanje
    for ime, stevilka in imenik.items():
        f.write(ime) 
        f.write(',')
        f.write(stevilka)
        f.write('\n')
    f.close()
\end{lstlisting}
Štiri nize (\texttt{ime}, \texttt{','}, \texttt{stevilka} in \texttt{'$\backslash$n'} bi lahko združili skupaj in metodo \texttt{write} uporabili samo enkrat.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def shrani_imenik(ime_datoteke, imenik):
    f = open(ime_datoteke, mode='w') # prepisovanje
    for ime, stevilka in imenik.items():
        f.write(ime+','+stevilka+'\n')
    f.close()
\end{lstlisting}
Za pisanje pa bi lahko uporabili tudi funkcijo \texttt{print}. Tej moramo spremeniti privzeto ločilo (presledek) v zahtevano ločilo (vejica). Takole:
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def shrani_imenik(ime_datoteke, imenik):
    f = open(ime_datoteke, mode='w') # prepisovanje
    for ime, stevilka in imenik.items():
        print(ime, stevilka, sep=',', file=f)
    f.close()
\end{lstlisting}
\end{resitev}

\section{Kodiranje znakov}

Že na začetku poglavja smo omenili, da vsebino datoteke predstavlja zaporedje števil, ki jih lahko v primeru tekstovnih datotek pretvorimo v neoblikovan tekst oziroma neko zaporedje znakov. Vsak znak je torej shranjen kot neko število. \emph{Kodiranje} določa preslikavo, ki posamezno število oziroma \emph{kodo} preslika v določen znak. Do kode znaka lahko pridemo z uporabo vgrajene funkcije \texttt{ord}, ki ji kot argument podamo en znak:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> ord('a')
97
>>> ord('A')
65
\end{lstlisting}
Preslikavo lahko naredimo tudi v drugo smer (iz kode v znak), in sicer z uporabo funkcije \texttt{chr}, ki ji kot argument podamo kodo znaka:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> chr(97)
'a'
>>> chr(65)
'A'
\end{lstlisting}

Koda posameznega znaka je torej odvisna od uporabljenega kodiranja. Izkaže se, da so osnovni znaki ne glede na uporabljeno kodiranje zakodirani na enak način. Pri kodiranju teh se namreč uporablja 7-bitni standard ASCII \angl{ American Standard Code for Information Interchange}. Za kodiranje posameznega znaka lahko torej uporabimo 7 bitov, kar pomeni, da lahko zakodiramo $2^7=128$ različnih znakov. Pri tem je 32 kod rezerviranih za posebne znake (med te sodi npr. tudi znak za novo vrstico), torej nam ostane 96 kod, s katerimi moramo predstaviti male črke, velike črke, številke in različna ločila ter simbole. Izkaže se, da teh kod zelo hitro zmanjka in zato služijo zgolj predstavitvi osnovnih znakov in črk angleške abecede. Kaj pa naši šumnik, nemški preglasi in kitajske pismenke? Za predstavitev teh moramo uporabiti razširitrve kodiranja ASCII. Omenimo dve razširitvi, ki sta v pogosti uporabi v današnjem času. 

Kodne tabele \angl{code page} kodiranje ASCII razširjajo z dodatnim bitom, kar pomeni, da lahko z njihovo uporabo predstavimo dodatnih 128 znakov. To je sicer dovolj za znake č, ž in š, kaj pa za kitajske pismenke? Dodatnih kod seveda ni dovolj, da bi predstavili še te, poleg njih pa mogoče še črke iz cirilice, korejski hangul in še kaj drugega. Iz tega razloga se v različnih delih sveta uporabljajo različne kodne tabele. Pri nas je npr. v uporabi centralno-evropska kodna tabela \texttt{cp1250}, s katero lahko predstavimo tudi znake č, ž in š. Znak \texttt{č} je v tej kodni tabeli določen s kodo \texttt{232}. V Nemčiji uporabljajo zahodno-evropsko kodno tabelo \texttt{cp1252}, s katero sicer ne moremo predstaviti šumnikov, lahko pa predstavimo preglase.  V tej kodni tabeli koda \texttt{232} predstavlja znak \texttt{è}, kar ste mogoče že kdaj opazili, npr. pri predvajanju podnapisov.

Kljub temu, da se kodne tabele še vedno uporabljajo, je v današnjem času v večinski rabi standard \emph{unicode}, katerega pomemben predstavnik je kodiranje UTF-8. Pri tem je posamezen znak zapisan z minimalno 8 biti. V primeru, da se v našem besedilu pojavijo znaki, ki ne nastopajo v osnovnem ASCII kodiranju (npr. č), se zapis posameznega znaka razširi (V konkretnem primeru na 16-bitni zapis).

Zakaj se moramo s kodiranjem znakov ukvarjati v okviru osnov programiranja? Pri branju in pisanju datotek je zaželeno, da izrecno podamo kodiranje, ki ga želimo uporabiti. S tem se namreč izognemo težavam z napačno interpretacijo znakov. Če je nekdo zapisal datoteko z uporabo kodiranje UTF-8, mi pa jo poskusimo odpreti s kodiranjem cp1250, bo prišlo do napake ali pa bodo znaki dekodirani narobe. Če kodiranja ne podamo (kot ga nismo podali v primerih zgoraj), bo uporabljeno privzeto kodiranje našega operacijskega sistema. Poglejmo si še enkrat kaj se skriva za spremenljivko, preko katere odpremo datoteko:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open('stevila.txt')
>>> f 
<_io.TextIOWrapper name='stevila.txt' mode='r' encoding='cp65001'>
\end{lstlisting}
Kodiranje \angl{encoding} je v konkretnem primeru nastavljeno na \texttt{'cp650010'}, ki predstavlja nekakšen ekvivalent kodiranja UTF-8 v operacijskem sistemu Windows. Operacijski sistem Windows sicer pogosto uporablja kodiranje cp1250, Linux pa UTF-8. Zmešnjava je torej popolna. To lahko povzroči nemalo težav, zato je pri delu z datotekami pomembno, da vedno podamo način kodiranja. Dogovorimo se, da bomo od zdaj naprej pri delu z datotekami vedno podali način kodiranja, ki naj bo kar UTF-8. 

Kodiranje, ki ga želimo uporabiti pri pisanju ali branju datoteke, navedemo pri odpiranju datoteke s funkcijo \texttt{open} preko izbirnega argumenta \texttt{encoding}. Zapišimo datoteko z uporabo kodiranja UTF-8\footnote{Argument \texttt{encoding} bomo nastavili na vrednost \texttt{'utf8'}, \texttt{'utf-8'}, \texttt{'UTF8'} ali \texttt{'UTF-8'}.}:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open("posebni_znaki.txt", mode='w', encoding="utf8")
>>> f.write("čžš")
3
>>> f.close()
\end{lstlisting}
Zdaj datoteko preberimo z uporabo kodiranja cp1250:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open("posebni_znaki.txt", encoding="cp1250")
>>> f.read()
'ÄŤĹľĹ'
\end{lstlisting}

Rezultat je seveda napačen. Poskusimo še s pravilnim kodiranjem:
\begin{lstlisting}[language=Python, showstringspaces=false]
>>> f = open("posebni_znaki.txt", encoding="utf8")
>>> f.read()
'čžš'
\end{lstlisting}

Izbira ustreznega kodiranja pri delu z datotekami je torej pomembna. Dopolnimo naši funkciji za branje telefonskega imenika iz datoteke in njegovo zapisovanje v datoteko, saj je velika verjetnost, da bodo v imenih naših prijateljev nastopali tudi šumniki.

\begin{zgled}
Napiši funkciji za branje in shranjevanje telefonskega imenika v in iz datoteke, pri čemer je imenik podan kot slovar, v katerem ključi predstavljajo imena oseb, vrednosti pa njihove telefonske številke. Datoteka naj bo zakodirana z uporabo kodiranja UTF-8.
\end{zgled}
\begin{resitev}
Rešitev bo praktično enaka kot v prej, le da bomo pri odpiranju datoteke izbirni argument \texttt{encoding} postavili na vrednost \texttt{'utf8'}.
\begin{lstlisting}[language=Python, showstringspaces=false,numbers=left]
def shrani_imenik(ime_datoteke, imenik):
    # pri odpiranju datoteke podamo še kodiranje
    f = open(ime_datoteke, mode='w', encoding='utf8')
    for ime, stevilka in imenik.items():
        print(ime, stevilka, sep=',', file=f)
    f.close()

def preberi_imenik(ime_datoteke):
    # pri odpiranju datoteke podamo še kodiranje
    f = open(ime_datoteke, encoding='utf8') 
    imenik = {} # prazen slovar
    for vrstica in f:
        vrstica = vrstica.strip() # odstrani '\n'
        if vrstica: # vrstica ni prazna?
            ime, stevilka = vrstica.split(',') # razpakiraj
            imenik[ime] = stevilka # dodajanje vnosa
    return imenik
\end{lstlisting}
\end{resitev}
