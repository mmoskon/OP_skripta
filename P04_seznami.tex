\chapter{Seznami in metode}

\section{Sekvenčni podatkovni tipi}

Podatkovni tipi, ki smo jih srečali do sedaj, so bili večinoma namenjeni temu, da vanje shranimo posamezen (1) podatek. V spremenljivko, ki je pripadala podatkovnemu tipu \texttt{int}, smo npr. lahko shranili eno število. V določenih primerih pa se srečamo z veliko količino med seboj podobnih podatkov, nad katerimi želimo izvajati enake ali podobne operacije. V praksi bi to lahko pomenilo, da izvajamo ponavljajoče meritve enake količine, npr. dolžine skoka smučarjev skakalcev. Kaj narediti v takem primeru? Na podlagi našega dosedanjega znanja bi lahko za vsakega skakalca definirali svojo spremenljivko, kar pa ne bi bila ravno najboljša rešitev. Prvi problem tega pristopa bi bil, da je lahko skakalcev zelo veliko. V primeru skakalcev bi bila stvar mogoče še lahko obvladljiva, kaj pa če npr. merimo prisotnost transkriptov genov v celici, ki ima par tisoč genov? Drugi problem je ta, da moramo vsako izmed spremenljivk obravnati ločeno, kar nas bo pripeljalo do ogrome količine nepregledne \emph{copy--paste} kode. Tretji problem tega pristopa je, da včasih ne vemo čisto točno koliko meritev bomo imeli in koliko spremenljivk bomo imeli (koliko bo skakalcev, koliko je genov v opazovani celici) in zato težko povemo koliko spremenljivk moramo posebej obravnati. K sreči pa obstajajo t.i. \emph{sekvenčni podatkovni tipi}, v katere lahko shranjujemo večjo količino podatkov oziroma več kot en podatek. Dodatna prednost sekvenčnih podatkovnih tipov je ta, da lahko podatke sproti dodajamo in ne potrebujemo vnaprej definirati števila podatkov, ki jih bomo na koncu imeli. Mimogrede, tudi nizi so sekvenčni podatkovni tipi, saj lahko vanje shranjujemo večjo količino podatkov, ki v tem primeru predstavljajo znake oziroma enočrkovne nize. 

\section{Kaj so seznami?}

Drug predstavnik sekvenčnih podatkovnih tipov je seznam oziroma \texttt{list}. Za razliko od nizov lahko vanj shranimo poljubne podatke, kot so npr. števila, nizi in tudi drugi seznami. Dodatna prednost uporabe seznamov je ta, da lahko elemente v seznamu dodajamo sproti, zato dolžine seznama ni treba vnaprej definirati. Lahko torej začnemo s praznim seznamom in vsakič, ko dobimo podatek o novi meritvi, tega v seznam dodamo. 

Sezname definiramo z oglatimi oklepaji \texttt{[} in \texttt{]}, znotraj katerih naštejemo elemente. Prazen seznam bi naredili takole
\begin{lstlisting}[language=Python]
>>> prazen_seznam = []
\end{lstlisting}
Seznam, ki vsebuje približno naključne dolžine skokov smučarjev skakalcev pa takole
\begin{lstlisting}[language=Python]
>>> dolzine = [121.4, 143.1, 105.2, 99.3]
\end{lstlisting}
V isti seznam bi lahko zapisali tudi različne podatkovne tipe, npr. 3 cela števila, 1 decimalko, 5 nizov itd., čeprav v praksi tega ne srečamo pogosto. Ponavadi v sezname shranjujejmo podatke, ki pripadajo istemu podatkovnemu tipu, saj se ti podatke nanašajo na ponavljajoče izvajanje npr. določene meritve. Na koncu lahko zato z uporabo seznamov izvedemo določene statistike, npr. kdo je skočil najdlje, kakšna je povprečna dolžina skoka, koliko ljudi je skočilo itd.

\section{Indeksiranje seznamov}
Seznami so urejeni. To pomeni, da je vrstni red, v katerem naštejemo elemente seznama, pomemben. Vsak element v seznamu ima namreč svoj \emph{indeks}. Pri tem se indeksiranje začne z najmanjšim pozitivnim številom, ki v računalništvu ni 1, ampak 0. Indeksi bodo torej šli od števila 0 do dolžine seznama -- 1. V primeru zgoraj definiranega seznama \texttt{dolzine} gredo torej indeksi od 0 do 3, saj seznam vsebuje 4 elemente:

\begin{tabular}{cccccc}
\textbf{indeksi} & & 0 & 1 & 2 & 3\\
%\hline
\texttt{dolzine} & = & \texttt{[121.4,}& \texttt{143.1,} & \texttt{105.2,} & \texttt{99.3]}
\end{tabular}

Do elementa na določenem indeksu lahko pridemo z indeksiranjem, ki ga izvedemo tako, da za imenom spremenljivke indeks zapišemo v oglatih oklepajih:
\begin{lstlisting}[language=Python]
ime_seznama[indeks]
\end{lstlisting}
Do dolžine skoka 0-tega skakalca bi torej prišli takole:
\begin{lstlisting}[language=Python]
>>> dolzine[0]
121.4
\end{lstlisting}

Kaj pa do zadnjega skakalca? Do dolžine seznama lahko pridemo preko vgrajene funkcije \texttt{len}:
\begin{lstlisting}[language=Python]
>>> len(dolzine)
4
\end{lstlisting}
Funkcijo lahko torej uporabimo pri indeksiranju, kadar ne vemo točno, koliko elementov ima seznam. Do zadnjega elementa torej pridemo takole:
\begin{lstlisting}[language=Python]
>>> dolzine[len(dolzine)-1]
99.3
\end{lstlisting}
Zakaj moramo od dolžine seznama odšteti 1? Ker smo začeli šteti s številom 0, bo zadnji indeks enak dolžini seznama -- 1. Kaj pa če vseeno poskusimo indeksirati po indeksu, ki ga v seznamu ni? V tem primeru seveda dobimo napako:
\begin{lstlisting}[language=Python]
>>> dolzine[len(dolzine)]
Traceback (most recent call last):
  File "<pyshell#16>", line 1, in <module>
    dolzine[len(dolzine)]
IndexError: list index out of range
\end{lstlisting}
Kot smo do zdaj že večkrat videli ima Python veliko lepih lastnosti. Ena izmed njih je tudi ta, da lahko uporabljamo negativno indeksiranje, pri čemer indeks -1 predstavlja zadnji element, indeks -2 predzadnji in tako naprej. Dolžine skokov imajo torej tudi negativne indekse:

\begin{tabular}{cccccc}
\textbf{indeksi} & & -4 & -3 & -2 & -1\\
%\hline
\texttt{dolzine} & = & \texttt{[121.4,}& \texttt{143.1,} & \texttt{105.2,} & \texttt{99.3]}
\end{tabular}

Prednost takega načina indeksiranja je v tem, da lahko na zelo enostaven način pridemo do zadnjega elementa seznama (brez funkcije \texttt{len}):
\begin{lstlisting}[language=Python]
>>> dolzine[-1]
99.3
\end{lstlisting}

Mimogrede, podobno kot lahko indeksiramo elemente seznamov, lahko indeksiramo tudi elemente nizov. Prav tako lahko dolžino niza preverimo s funkcijo \texttt{len}.
\begin{lstlisting}[language=Python]
>>> niz = "banana"
>>> niz[0]
"b"
>>> niz[-1]
"a"
>>> len(niz)
6
\end{lstlisting}

\section{Operatorji nad seznami}

Nad seznami lahko uporabimo različne operatorje, ki smo jih do zdaj uporabljali že npr. nad nizi. Nize smo npr. lahko med seboj seštevali (temu smo sicer rekli konkatenacija oziroma lepljenje). Med seboj lahko seštevamo tudi sezname:
\begin{lstlisting}[language=Python]
>>> [1,2,3] + [4,5,6]
[1,2,3,4,5,6]
\end{lstlisting}
Ne moremo pa seznamom prišteti nečesa, kar ni seznam, npr. števila:
\begin{lstlisting}[language=Python]
>>> [1,2,3]+4
Traceback (most recent call last):
  File "<pyshell#20>", line 1, in <module>
    [1,2,3]+4
TypeError: can only concatenate list (not "int") to list
\end{lstlisting}
Lahko pa sezname množimo s celimi števili:
\begin{lstlisting}[language=Python]
>>> [1,2,3]*4
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
\end{lstlisting}
S čim drugim jih ni smiselno množiti, zato Python tega ne podpira:
\begin{lstlisting}[language=Python]
>>> [1,2,3]*[4,5,6]
Traceback (most recent call last):
  File "<pyshell#22>", line 1, in <module>
    [1,2,3]*[4,5,6]
TypeError: can't multiply sequence by non-int of type 'list'
\end{lstlisting}

Nad seznami lahko uporabimo tudi operatorja vsebovanosti \texttt{in} in \texttt{not in}, ki vrneta \texttt{True} ali \texttt{False} v odvisnosti od tega ali je nekaj v seznamu vsebovano ali ne:
\begin{lstlisting}[language=Python]
>>> 1 in [1,2,3]
True
>>> 1 not in [1,2,3]
False
\end{lstlisting}

Sezname lahko primerjamo z drugimi seznami z uporabo primerjalnih operatorjev. Takole preverjamo enakost oziroma neenakost dveh seznamov:
\begin{lstlisting}[language=Python]
>>> [1,2,3] == [1,2,3]
True
>>> [1,2,3] != [1,2,3]
False
\end{lstlisting}
Lahko tudi ugotavljamo, če je prvi seznam manjši od drugega (besedico manjši bi lahko zamenjali tudi z večji, manjši ali enak ter večji ali enak):
\begin{lstlisting}[language=Python]
>>> [1,2,3] < [1,2,3,4]
True
>>> [1,3,3] < [1,2,3]
False
\end{lstlisting}
Primerjalni operatorji nad seznami delujejo podobno kot nad nizi in sicer se gre za leksikografsko primerjanje. Leksikografsko primerjanje je npr. uporabljeno pri sortiranju besed v slovarju, in sicer gre za to, da med seboj primerjamo istoležne elemente seznama, dokler ne pridemo do neenakosti oziroma do konca seznama. V zgornjem primeru smo prišlo do konca prvega seznama. Ker je nekaj kar ne obstaja načeloma manjše kot nekaj kar obstaja, je Python vrnil, da je prvi seznam manjši od drugega. V drugem primeru se je primerjanje ustavilo pri elementih na indeksu 1, saj sta elementa na tem indeksu različna. Ker 3 ni manjše od 2, je Python ugotovil, da prvi seznam ni manjši od drugega in vrnil rezultat \texttt{False}.

\section{Spreminjanje in brisanje elementov seznama}

Videli smo že, da lahko do elementov seznama dostopamo preko indeksiranja. Preko indeksiranja pa lahko vrednosti v seznamih tudi spreminjamo. Kako? Tako, da vrednosti na določenem indeksu priredimo neko novo vrednost:
\begin{lstlisting}[language=Python]
seznam[indeks] = nova_vrednost
\end{lstlisting}

Tudi brisanje elementov iz seznama lahko izvajamo s pomočjo indeksiranje, le da tokrat pred indeksrianjem uporabimo besedico \textbf{\texttt{del}}:
\begin{lstlisting}[language=Python]
del seznam[indeks]
\end{lstlisting}

\section{Vgrajene funkcije nad seznami}
Srečali smo že funkcijo \texttt{len}, s pomočjo katere lahko ugotovimo kakšna je dolžina seznama. Nad seznami pogosto uporabljamo še druge vgrajene funkcije, izmed katerih so pogosto uporabljene \texttt{min}, \texttt{max} in \texttt{sum}.

Funkcija \texttt{min} vrne najmanjši funkcija \texttt{max} pa največji element v seznamu glede na relacijo \texttt{<}. Zdaj lahko končno ugotovimo kakšna je bila dolžina najdaljšega skoka:
\begin{lstlisting}[language=Python]
>>> max(dolzine)
143.1
\end{lstlisting}

Izračunamo lahko tudi povprečno dožino skoka
\begin{lstlisting}[language=Python]
>>> sum(dolzine)/len(dolzine)
117.25
\end{lstlisting}
Nad seznami lahko uporabimo še druge vgrajene funkcije. Nekatere izmed njih bomo srečali kasneje, druge pa boste zagotovo našli, če se bo takšna potreba pokazala. 

\section{Metode}

Nad seznami lahko torej uporabljamo vgrajene funkcije, ki so pač v Pythonu na voljo. Te funkcije lahko sicer uporabimo na poljubnem podatku, ki ni nujno seznam. Obstaja poseben nabor funkcij, ki jih lahko uporabljamo samo nad seznami. 

Tem funkcijam pravimo \emph{metode seznamov}. V splošnem se izraz \emph{metode} uporablja za posebno družino funkcij, ki pripadajo določenemu \emph{objektu}. Kaj je objekt zaenkrat ne bomo podrobneje razlagali. Lahko pa povemo, da so seznami objekti (pravzaprav je skoraj vse v Pythonu objekt). Kakorkoli že metode so tiste funkcije, ki pripadajo določenemu objektu. Do posamezne metode seznama lahko pridemo s spodnjim klicem:
\begin{lstlisting}[language=Python]
ime_seznama.ime_metode(argumenti)
\end{lstlisting}
Klic metode je torej podoben kot klicu običajne funkcije, le da moramo pred imenom metode podati ime objekta, preko katerega oziroma nad katerim metodo kličemo, imeni pa ločimo s piko (\texttt{.}).

Če delamo v okolju IDLE ali v kakšnem še pametnejšem okolju, nam bo to po izpisu imena seznama in pikice podalo seznam metod, ki jih imamo na razpolago. Ko v okolju IDLE npr. napišemo
\begin{lstlisting}[language=Python]
>>> dolzine.
\end{lstlisting}
se po nekaj sekundah pojavi seznam metod: \texttt{append}, \texttt{copy}, \texttt{clear} itd.

Metode torej razširjajo vgrajene funkcije okolja Python in so vezane na točko določen podatkovni tip. Če bi npr. enako stvar kot zgoraj poskusili z nizom, bi dobili drug seznam metod, ki so vezane nad nizom. Metodam kot argument za razliko od vgrajenih funkcij ni potrebno podati seznama (ali pa niza) nad katerim jih želimo izvesti, saj smo seznam (ali pa niz) podali že pred piko -- že s samim klicom smo povedali nad čim želimo metodo pognati. Metode vseeno velikokrat vsebujejo določene argumente, ki pač določijo kaj in kako naj metoda nad objektom naredi. 

Prav tako kot obstaja kar veliko vgrajenih funkcij, obstaja tudi veliko metod nad seznami. Natančneje si bomo v nadaljevanju tega poglavja pogledali tiste, ki jih uporabljamo pogosteje.

\section{Dodajanje elementov}

Dodajanje elementov v seznam je pogosta operacija, zato jo lahko izvedemo na več načinov. Enega smo pravzaprav še srečali, saj lahko za dodajanje elementov v seznam uporabimo kar operator \texttt{+}, ki omogoča lepljenje seznamov. Če želimo element seznamu dodati, bomo obstoječemu seznamu prišteli seznam, ki vsebuje ta element. Takole:
\begin{lstlisting}[language=Python]
seznam = seznam + [element]
\end{lstlisting}
oziroma malo lepše:
\begin{lstlisting}[language=Python]
seznam += [element]
\end{lstlisting}
Tole dvoje sicer ni popolnoma enako, ampak zaenkrat recimo, da je bolje uporabiti spodnjo različico. 

Elemente lahko v sezname dodajamo tudi preko metode \texttt{append} in metode \texttt{extend}. Obe metodi bosta dodajali na koncu seznama. Razlika je v tem, da v primeru \texttt{append} dodajamo en element, zato ta metoda kot argument prejme poljuben element, ki ga bomo v seznam dodali. Dodajanje bi torej izvedli takole:
\begin{lstlisting}[language=Python]
seznam.append(element)
\end{lstlisting}
Metoda sicer ne bo ničesar vrnila, bo pa naš seznam spremenila. Primer uporabe je sledeč:
\begin{lstlisting}[language=Python]
>>> seznam = [1,2,3]
>>> seznam.append(4)
>>> seznam
[1,2,3,4]
\end{lstlisting}
Podobno lahko uporabimo metodo \texttt{extend}, ki v seznam dodaja drug seznam. Kot argument moramo torej metodi \texttt{extend} podati seznam, ki ga želimo v obstoječ seznam dodati. Takole:
\begin{lstlisting}[language=Python]
seznam.extend([element])
\end{lstlisting}
Oziroma na prejšnjem zgledu takole:
\begin{lstlisting}[language=Python]
>>> seznam = [1,2,3]
>>> seznam.extend([4])
>>> seznam
[1,2,3,4]
\end{lstlisting}

\begin{zgled}
Napiši program, ki ga bo lahko uporabil sodnik smučarskih skokov. Program naj sodnika sprašuje po dolžini skoka. V primeru, da sodnik vnese število večje od 0, naj program to število shrani v seznam. Če sodnik vpiše številko 0, naj program izpiše dolžino najdaljšega skoka in povprečno dolžino skoka
\end{zgled}
\begin{resitev}
Sodnikova števila lahko beremo preko funkcije \texttt{input}, katere rezultat moramo pretvoriti še v tip \texttt{float}. Beremo dokler sodnik ne vnese števila 0, medtem pa dolžine shranjujemo v seznam. Na koncu samo še izračunamo povprečno dolžino skoka, poleg tega pa izpišemo tudi najdaljši skok. Program je sledeč:
\begin{lstlisting}[language=Python,numbers=left]
d = float(input("Vpisi dolzino: ")) # prvo branje
dolzine = [] # na zacetku ni nobene dolzine
while d > 0: # dokler je dolzina veljavna
    dolzine.append(d) # dodaj dolzino
    d = float(input("Vpisi dolzino: ")) # ponovno branje
print("Najdaljsi skok:", max(dolzine))
print("Povprecna dolzina:", sum(dolzine)/len(dolzine))
\end{lstlisting}
\end{resitev}
Prednost zgornjega programa je v tem, da deluje ne glede na to koliko skokov je v seznamu. Vse dokler sodnik ne vnese kakšne neumnosti.



\section{Branje seznamov iz ukazne vrstice}
Včasih pa bi si želeli celoten seznam prebrati z enim samim uporabnikovim vnosom. Torej bomo spet uporabili funkcijo \texttt{input}. Spomnimo se, da funkcija \texttt{input} uporabnikov vnos vedno zapiše v niz oziroma podatkovni tip \texttt{str}, ne glede na to kaj je uporabnik vnesel. Tak niz smo v prejšnjih s funkcijo \texttt{int} pretvorili v celo število ali pa s funkcijo \texttt{float} v decimalno, smo želeli podan vnos v nadaljevanju obravnavati kot število. Kaj pa če bi želeli niz, ki ga je vnesel uporabnik, pretvoriti v seznam? Na prvo žogo bi lahko rekli, da pač uporabimo funkcijo \texttt{str}. Poskusimo:
\begin{lstlisting}[language=Python]
>>> seznam = list(input("Vnesi seznam: "))
Vnesi seznam: [1,2,3]
>>> seznam
['[', '1', ',', '2', ',', '3', ']']
\end{lstlisting}
To torej ni točno tisto, kar smo želeli. Dobili smo namreč seznam vseh znakov, ki v podanem vnosu nastopajo.

Kaj bi pravzaprav radi dosegli? To, da se niz, ki ga uporabnik poda funkciji \texttt{input} obravnava na enak način, kot če bi isti niz vpisal v ukazno vrstico. Temu namenu je namenjena funkcija \texttt{eval}, ki kot argument sprejme niz in ga izvede kot Python kodo. Poskusimo še to:
\begin{lstlisting}[language=Python]
>>> seznam = eval(input("Vnesi seznam: "))
Vnesi seznam: [1,2,3]
>>> seznam
[1,2,3]
\end{lstlisting}
V tem primeru stvar deluje, kot bi si želeli. Povadimo še na zgledu.

\begin{zgled}
Napiši program, ki ga bo lahko uporabil sodnik smučarskih skokov. Programu naj sodnik vnese seznam dolžin smučarskih skokov, program pa naj izpiše dolžino najdaljšega skoka in povprečno dolžino skoka.
\end{zgled}
\begin{resitev}
Rešitev bo podobna kot prej, le da tokrat ne potrebujemo zanke.
\begin{lstlisting}[language=Python,numbers=left]
dolzine = eval(input("Vnesi dolzine: "))
print("Najdaljsi skok:", max(dolzine))
print("Povprecna dolzina:", sum(dolzine)/len(dolzine))
\end{lstlisting}
Slabost programa je ta, da mora sodnik zdaj vse dolzine vnesti naenkrat. 
\end{resitev}

Uporaba funkcije \texttt{eval} je sicer lahko v določenih primerih nevarna (če imamo zlobne uporabnike), saj bo slepo izvedla kodo, ki jo bo uporabnik podal.

\section{Sortiranje seznamov}

Zaenkrat znamo določiti najdaljši skok, ne znamo p določiti najdaljše tri. Najdaljše tri skoke bi lahko poiskali tako, da seznam posortiramo, tako da vsebuje skoke od najdaljšega do najkrajšega, potem pa izpišemo skoke na indeksih 0, 1 in 2. 

Sortiranje seznamov lahko izvedemo z metodo \texttt{sort}:
\begin{lstlisting}[language=Python]
>>> dolzine.sort()
>>> dolzine
[99.3, 105.2, 121.4, 143.1]
\end{lstlisting}
Metoda \texttt{sort} torej sortira seznam, nad katerim smo jo poklicali, in ničesar ne vrača. Opazimo tudi, da je seznam sortirala od najmanjše vrednosti do največje. Najboljše skoke bi torej lahko izpisali tako, da bi izpisali zadnje tri dolžine iz seznama. Lahko pa seznam sortiramo v obratnem vrstnem redu, tako da metodi \texttt{sort} nastavimo opcijski (izbirni) argument \texttt{reverse} na vrednost \texttt{True}. Do dokumentacije metode \texttt{sort} lahko pridemo preko funkcije \texttt{help}:
\begin{lstlisting}[language=Python]
>>> help(list.sort)
Help on method_descriptor:

sort(self, /, *, key=None, reverse=False)
    Stable sort *IN PLACE*.
\end{lstlisting}
Dokumentacija ni nič kaj preveč izčrpna, vidimo pa lahko, da metoda sort sprejema tudi dva opcijska argumenta, in sicer \texttt{key}, ki je privzeto enak vrednosti \texttt{None} in \texttt{reverse}, ki je privzeto enak vrednosti \texttt{False}. Opcijski argumenti so tisti argumenti, ki imajo nastavljene privzete vrednosti. Če ob klicu ne specificiramo drugačnih vrednosti, bodo pač uporabljene privzete vrednosti. Privzete vrednosti pa lahko \emph{povozimo}, tako da specificiramo drugačne vrednosti. Vrstni red urejanja bi lahko spremenili tako, da bi argument \texttt{reverse} nastavili na vrednost \texttt{True}. V našem primeru takole:
\begin{lstlisting}[language=Python]
>>> dolzine.sort(reverse=True)
>>> dolzine
[143.1, 121.4, 105.2, 99.3]]
\end{lstlisting}

Rešimo zdaj celoten zgled od začetka do konca.
\begin{zgled}
Napiši program, ki ga bo lahko uporabil sodnik smučarskih skokov. Programu naj sodnik vnese seznam dolžin smučarskih skokov, program pa naj izpiše najdaljše tri skoke.
\end{zgled}

\begin{resitev}
Zdaj bo branju seznama sledilo sortiranje in izpis zmagovalnih dolžin.
\begin{lstlisting}[language=Python,numbers=left]
dolzine = eval(input("Vnesi dolzine: "))
dolzine.sort(reverse=True)
print("1. mesto", dolzine[0])
print("2. mesto", dolzine[1])
print("3. mesto", dolzine[2])
\end{lstlisting}
\end{resitev}

Prej smo videli, da metoda \texttt{sort} sprejema tudi izbirni argument \texttt{key}, s katerim lahko določimo, preko katerega naj funkcija sortira. Če bi želeli npr. sortirati seznam po absolutnih vrednostih, bi argumentu \texttt{key} priredili funkcijo \texttt{abs}. Takole:
\begin{lstlisting}[language=Python]
>>> seznam = [-100, 10, -1, -5, 50]
>>> seznam.sort(key=abs)
>>> seznam
[-1, -5, 10, 50, -100]
\end{lstlisting}

Sezname (in še kaj drugega) pa bi lahko sortirali tudi preko vgrajene funkcije \texttt{sorted}. Ta funkcija deluje na enak način kot metoda \texttt{sort}, le da podanega seznama ne sortira, ampak vrne sortiran seznam. Poglejmo si na zgledu:
\begin{lstlisting}[language=Python]
>>> seznam = [-100, 10, -1, -5, 50]
>>> sorted(seznam)
[-1, -5, 10, 50, -100]
>>> seznam
[-100, 10, -1, -5, 50]
\end{lstlisting}
Funkcija torej vrne sortiran seznam, izhodiščni seznam pa je ostal nespremenjen. 

\section{Seznami seznamov}




\section{Funkcija \texttt{range}}

\section{Rezine}

\section{Sprehajanje čez sezname}