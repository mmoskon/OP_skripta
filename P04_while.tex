\chapter{Zanka \texttt{while}}

\section{Kaj so zanke?}

Z uporabo stavka \texttt{if} lahko torej izbrane stavke izvedemo samo v primeru, ko je nek pogoj izpolnjen. Včasih pa bi želeli izbrane stavke izvajati vse \textbf{dokler} \angl{while} je nek pogoj izpolnjen. To omogočajo \textbf{zanke}. V sledečem poglavju si bomo podrobneje pogledali zanko \texttt{while}. 

\section{Zanka \texttt{while}}

Razliko med izvedbo pogojnega stavka \texttt{if} in zanko \texttt{while} prikazuje slika \ref{img:while_vs_if}.

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{img/while_vs_if.pdf}
    \caption{Razlika med izvedbo pogojnega stavka \texttt{if} (črtkana linija rdeče barve) in zanko \texttt{while} (polna linija rdeče barve). }
    \label{img:while_vs_if}
\end{figure}
Po izvedbi pogojnega dela stavka \texttt{if} se izvajanje programa nadaljuje v delu, ki sledi pogojnemu stavku. Po drugi strani se po izvedbi pogojnega dela zanke \texttt{while}, recimo tem stavkom raje \emph{telo zanke}, izpolnjenost pogoja v \emph{glavi zanke} (glej primer v nadaljevanju) ponovno preveri. Telo oziroma vsebina zanke se bo torej izvajalo vse dokler bo pogoj izpolnjen. Zanko \texttt{while} lahko zapišemo takole:
\begin{lstlisting}[language=Python]
while pogoj: # glava zanke
    # telo zanke
    ...
# nadaljevanje programa
...
\end{lstlisting}
Zapis zanke \texttt{while} je torej zelo podoben zapisu stavka \texttt{if}. Glavi zanke sledi telo zanke oziroma njena vsebina, ki se izvaja vse dokler je pogoj izpolnjen. Enemu obhodu zanke pravimo tudi \texttt{iteracija} zanke. Pogoje za izvedbo nove iteracije zanke lahko zapisujemo na popolnoma enak način kot pri stavku \texttt{if}. Prav tako kot pri stavku \texttt{if} vsebino zanke definiramo tako, da stavke znotraj telesa zanke zamikamo. Izvajanje zanke \texttt{while} ponazarja diagram poteka na sliki \ref{img:while1}.

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{img/while1.pdf}
    \caption{Potek izvajanja zanke \texttt{while}.}
    \label{img:while1}
\end{figure}

Zanke torej lahko uporabljamo takrat, ko želimo nekaj ponavljati, dokler je določen pogoj izpolnjen. Npr., dokler uporabnik ne poda veljavnega vnosa, dokler ni spremenljivka -- števec, ki šteje koliko ponovitev smo že naredil, dosegla določene vrednosti ali pa dokler sta števili različni. 

\section{Štetje z zanko \texttt{while}}

Zanko \texttt{while} bi lahko uporabili torej tudi za štetje. Za ta namen je sicer boljša zanka \texttt{for}, ki jo bomo spoznali malo kasneje. Poglejmo si zgled.
\begin{zgled}
Napiši program, ki šteje od 0 do števila, ki ga je vnesel uporabnik. Vsa števila naj program tudi izpiše
\end{zgled}
\begin{resitev}
Število, do katerega smo že prešteli, si bomo morali nekam zabeležiti, npr. v spremenljivko z imenom \texttt{i}. Šteti bomo glede na navodila začeli s številom 0. Torej bomo spremenljivko \texttt{i} na začetku postavili na vrednost 0. Končali bomo s številom, ki ga je vnesel uporabnik, recimo \texttt{n}. Pogoj za štetje naprej bo torej \texttt{i <= n}. Znotraj zanke \texttt{while} bomo trenutno število (\texttt{i}) izpisali, poleg tega moramo trenutno število tudi povečati, saj bo sicer pogoj za vedno izpolnjen. 
\begin{lstlisting}[language=Python,numbers=left]
n = int(input("Vpiši število do katerega želiš šteti: "))
i = 0 # števec s katerim bomo šteli
while i <= n: # smo ze prešteli do konca?
    print(i)
    i = i + 1 # povečanje števca za 1
\end{lstlisting}
\end{resitev}

\section{Iskanje največjega skupnega delitelja}

Povadimo uporabo zanke \texttt{while} na programu, ki poišče največji skupni delitelj dveh števil. Tega bi malo težje napisali z zanko \texttt{for} (vsaj v tej obliki). 

\begin{zgled}
Napiši program, ki od uporabnika prebere dve celi števili in poišče največji skupni delitelj teh dveh števil z uporabo Evklidovega algoritma.
\end{zgled}
\begin{resitev}
Osnovna različica Evklidovega algoritma deluje tako, da manjše število odšteva od večjega, dokler sta števili različni. Ko števili postaneta enaki, smo našli skupnega delitelja. Program bo torej manjše število odšteval od večjega, dokler sta števili različni. Uporabili bomo zanko \texttt{while} (dokler sta števili različni). Znotraj zanke bomo uporabili še stavek \texttt{if}, s pomočjo katerega bomo ugotovili, katero število je manjše. Ko bosta števili postali enaki, bomo enega izmed njih izpisali (vseeno katerega, ker sta enaki), saj ta predstavlja največji skupni delitelj števil, ki sta bili podani na začetku. 
\begin{lstlisting}[language=Python,numbers=left]
st1 = int(input("Vnesi prvo število: "))
st2 = int(input("Vnesi drugo število: "))

while st1 != st2: # dokler sta števili različni
    if st1 < st2: # drugo število je večje
        st2 = st2 - st1
    else: # prvo število je večje
        st1 = st1 - st2

# konec vsebine zanke 
# števili sta tu enaki, zato je vseeno katero izpišem
print(st1) 
\end{lstlisting}
Opomba: vsebina stavka \texttt{if} je zamaknjena dvakrat, saj je zapisana tako znotraj stavka \texttt{if} kot tudi znotraj zanke \texttt{while}!
\end{resitev}



\section{Stavek \texttt{+=}}
Znotraj zanke smo števec povečali za 1 z izvedbo prireditvenega stavka
\begin{lstlisting}[language=Python]
i = i + 1 # povečanje števca za 1
\end{lstlisting}
Ker je tak način povečevanja vrednosti zelo pogost, v jeziku Python obstaja bližnjica
\begin{lstlisting}[language=Python]
i += 1 # povečanje števca za 1
\end{lstlisting}
Bistvo zgornjega stavka je, da izvedemo aritmetično operacijo seštevanja in rezultat priredimo spremenljivki, nad katero smo operacijo izvedli. Na podoben način lahko operator prirejanja \texttt{=} kombiniramo z drugimi aritmetičnimi operatorji in števili:
\begin{lstlisting}[language=Python]
>>> x = 10
>>> x += 1 # povečaj za 1
>>> x
11
>>> x -= 2 # zmanjšaj za 2
>>> x
9
>>> x *= 5 # pomnoži s 5
>>> x
45
>>> x /= 9 # deli z 9
>>> x
5.0
>>> x **= 2 # potenciraj na 2
>>> x
25.0
\end{lstlisting}

\section{Neskončna zanka}

Kaj pa bi se zgodilo, če bi števec v prejšnjem zgledu znotraj zanke pozabili povečati? Spremenljivka \texttt{i} (oziroma števec) bi ostala na vrednosti 0 ne glede na to koliko iteracij zanke bi se izvedlo. To pomeni, da bi bil pogoj za vedno izpolnjen (\texttt{True}). Kdaj bi se taka zanka končala? Ker je pogoj vedno resničen, se taka zanka nikoli ne konča in tak program je potrebno končati na silo (v okolju Python je temu namenjena kombinacija tipk \texttt{ctrl + c}). Na take stvari moramo torej pri programiranju z zanko \texttt{while} paziti. Zanki, ki se nikoli ne konča, pravimo \emph{neskončna zanka} \angl{infinite loop}.

\section{Stavek \texttt{break}}
Zanko pa lahko prekinemo tudi drugače kot z neizpolnjenostjo pogoja v glavi zanke. Uporabimo lahko namreč stavek \texttt{break}, ki prekine izvajanje zanke brez preverjanja pogoja v glavi zanke. Primer uporabe stavka \texttt{break} ponazarja spodnja koda
\begin{lstlisting}[language=Python]
while pogoj:
    # telo zanke
    ...
    if dodaten_pogoj: 
        break # prekine izvajanje zanke
# nadaljevanje programa
...
\end{lstlisting}
Izvedbo primera prikazuje slika \ref{img:while2}. 
\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{img/while2.pdf}
    \caption{Primer uporabe stavka \texttt{break} znotraj zanke \texttt{while}.}
    \label{img:while2}
\end{figure}

Stavek \texttt{break} ponavadi uporabljamo v kombinaciji z dodatnim pogojem. V primeru, da je slednji izpolnjen, se izvajanje zanke prekine predčasno. Poglejmo si to na enostavnem zgledu. 
\begin{zgled}
Napiši program, ki od uporabnika sprejme njegovo ime in ga pozdravi. Program naj uporabnika ne spusti naprej, dokler ne vnese veljavnega imena. Pri tem naj bo veljavno vsako ime, ki je različno od praznega niza.
\end{zgled}
\begin{resitev}
Program lahko napišemo tako, da od uporabnika preberemo ime in ga shranimo kot niz. Potem izvajamo zanko \texttt{while} vse dokler je niz prazen. V telesu zanke moramo uporabniku seveda dati možnost, da vnese nekaj drugega kot prazen niz (sicer smo spet pri neskončni zanki). Za zanko lahko uporabnika pozdravimo, saj tukaj niz zagotovo ni več prazen.
\begin{lstlisting}[language=Python,numbers=left]
ime = input("Vnesi ime: ")
# če je vnos pravilen, se telo zanke nikoli ne izvede
while ime == "": # lahko bi pisali tudi while not ime:
    # popravni izpit
    print("Vnesel si prazen niz!")
    ime = input("Vnesi ime: ")
# zdaj ime zagotovo ni prazen niz
print("Pozdravljen(a)", ime)
\end{lstlisting}
Kar ni najlepše pri tej rešitvi je ponavljanje iste kode na dveh mestih (\emph{\texttt{ime = input("Vnesi ime: ")}}). Stvar lahko rešimo tako, da naredimo neskončno zanko, znotraj katere beremo ime. Če je prebrano ime neprazen niz, zanko prekinemo. Kako, če je pa zanka neskončna? Enostavno. S stavkom \texttt{break}. Kako pa naredimo neskončno zanko? Tako, da tej nastavimo pogoj, ki bo vedno resničen. Kot pogoj bi lahko v tem primeru napisali \emph{\texttt{1>0}}, \emph{\texttt{"a"=="a"}} ali pa kar \emph{\texttt{True}}.
\begin{lstlisting}[language=Python,numbers=left]
while True: # vedno izpolnjen pogoj
    ime = input("Vnesi ime: ")
    if ime: # enako kot if ime != ""
        break
    # če smo prišli do tu, je niz prazen
    print("Vnesel si prazen niz!")
print("Pozdravljen(a)", ime)
\end{lstlisting}

\end{resitev}


Poglejmo si še en malo težji zgled z uporabo stavka \texttt{break}. 

\begin{zgled}
Napiši program, ki od uporabnika prebere dve celi števili in izpiše, če sta števili tuji. Števili sta tuji, če nimata nobenega skupnega delitelja, ki je večji od 1.
\end{zgled}
\begin{resitev}
Nalogo bi lahko rešili tako, da bi poiskali največji skupni delitelj podanih števil (naj bosta to števili \texttt{st1} in \texttt{st2}) in pogledali, če je ta večji od 1. Tokrat se bomo rešitve lotili na malo drugačen način. Preverili bomo, če med kandidati za skupne delitelje obstaja kakšno število, ki deli obe števili, pri čemer bodo kandidati v razponu od števila 2 do manjšega števila, torej do vrednosti \texttt{min(st1, st2)}. V primeru, da med kandidati najdemo eno število, ki deli obe podani števili (ostanek po deljenju posameznega števila s kandidatom je enak 0 (\texttt{st \% delitelj == 0}), lahko takoj izpišemo, da števili nista tuji.
\begin{lstlisting}[language=Python,numbers=left]
st1 = int(input("Vnesi prvo število: "))
st2 = int(input("Vnesi drugo število: "))

delitelj = 2 # začetna vrednost kandidata

# kandidat/delitelj gre do manjšega
while delitelj <= min(st1, st2): 
    # ali delitelj deli obe števili?
    if st1 % delitelj == 0 and st2 % delitelj == 0:
        print("Števili nista tuji")
    delitelj += 1
\end{lstlisting}
Rešitev je še nepopolna, saj izpis poda samo v primeru, ko števili nista tuji. Kako bi lahko program dopolnili, tako da bi izpis podal tudi v primeru, ko sta števili tuji. Tak izpis lahko podamo samo v primeru, ko smo pregledali vse kandidate in nismo našli nobenega, ki deli obe števili. Pomagamo si lahko s pomožno spremenljivko tipa \texttt{bool}, v katero bomo shranili informacijo o tem, ali smo že našli kašnega delitelja. Pri tem bomo na začetku predpostavljali, da delitelja ni. Če ga bomo našli, bomo predpostavko popravili. Na koncu bomo preverili, če smo kakšnega delitelja našli. Če bo odgovor ne (\texttt{nasli == False}), bomo izpisali, da sta si števili tuji.
\begin{lstlisting}[language=Python,numbers=left]
st1 = int(input("Vnesi prvo število: "))
st2 = int(input("Vnesi drugo število: "))

delitelj = 2 # začetna vrednost kandidata
# predpostavljamo, da skupnega delitelja še nismo našli:
nasli = False 

# kandidat/delitelj gre do manjšega
while delitelj <= min(st1, st2):
    # ali delitelj deli obe števili?
    if st1 % delitelj == 0 and st2 % delitelj == 0:
        print("Števili nista tuji")
        nasli = True # popravimo predpostavko
    delitelj += 1

# če do tu skupnega delitelja nismo našli, potem ga ni        
if nasli == False: 
    print("Števili sta tuji")
\end{lstlisting}
Program sicer deluje pravilno, je pa njegov izpis moteč, v primeru, da najdemo več skupnih deliteljev dveh števil. Vsakič, ko najdemo skupnega delitelja, namreč izpišemo, da smo ga našli. Poleg tega bi lahko izvajanje zanke \texttt{while} prekinili takoj, ko smo našli enega skupnega delitelja, saj je to zadosten pogoj, da si števili nista tuji. Uporabimo lahko torej stavek \texttt{break}. Končna rešitev bo sledeča.
\begin{lstlisting}[language=Python,numbers=left]
st1 = int(input("Vnesi prvo število: "))
st2 = int(input("Vnesi drugo število: "))

delitelj = 2 # začetna vrednost kandidata
# predpostavljamo, da skupnega delitelja nismo našli:
nasli = False 

# kandidat za skupni delitelj gre do manjsega
while delitelj <= min(st1, st2): 
    # ali delitelj deli obe števili?
    if st1 % delitelj == 0 and st2 % delitelj == 0:
        print("Števili nista tuji")
        nasli = True # popravimo predpostavko
        break # lahko prenehamo z iskanjem
    delitelj += 1 

# če do tu skupnega delitelja nismo našli, potem ga ni        
if nasli == False: 
    print("Števili sta tuji")
\end{lstlisting}
\end{resitev}

\section{Veja \texttt{else}}
Ena izmed posebnosti jezika Python je tudi to, da lahko vejo \texttt{else} uporabljamo tudi v kombinaciji z zanko \texttt{while}. Takole:
\begin{lstlisting}[language=Python]
while pogoj:
    # telo zanke
    ...
else:
    # ko pogoj ni več izpolnjen
    ...
# nadaljevanje programa
...
\end{lstlisting}
Veja \texttt{else} se torej izvede, ko pogoj ni več izpolnjen. Vprašanje pa je ali se veja \texttt{else} izvede vsakič, ko se izvajanje zanke zaključi? Kakšna je razlika med stavki, ki sledijo zanki \texttt{while}, in stavki znotraj veje \texttt{else} zanke \texttt{while}? 

Do bistvene razlike med vejo \texttt{else} in običajnimi stavki, ki sledijo zanki \texttt{while}, pride, kadar zanko prekinemo s stavkom \texttt{break}. V tem primeru namreč skočimo iz zanke, s čimer preskočimo tudi njeno \texttt{else} vejo. Slednja se izvede samo v primeru, ko smo zanko prekinili po \emph{običajni} poti, tj. z neizpolnjenostjo pogoja v glavi zanke.  
\begin{lstlisting}[language=Python]
while pogoj:
    # telo zanke
    ...
    if dodaten_pogoj:
        break # prekini izvajanje zanke
else: # če zanka ni bila prekinjena z break
    # ko pogoj ni več izpolnjen
    ...
# nadaljevanje programa
...
\end{lstlisting}
Delovanje zgornjega programa ponazarja slika \ref{img:while3}.
\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{img/while3.pdf}
    \caption{Primer uporabe stavka \texttt{break} v kombinaciji z vejo \texttt{else} za zanko \texttt{while}.}
    \label{img:while3}
\end{figure}

Z vejo \texttt{else} lahko določene stavke po zaključku zanke \texttt{while} izvedemo samo v primeru, ko zanka ni bila prekinjena s stavkom \texttt{break}. Povadimo na prejšnjem zgledu še tole.

\begin{zgled}
Napiši program, ki od uporabnika prebere dve celi števili in izpiše, če sta števili tuji. Števili sta tuji, če nimata nobenega skupnega delitelja, ki je večji od 1.
\end{zgled}
\begin{resitev}
Del programa, kjer izpisujemo, da si števili nista tuji, bo ostal bolj ali manj nespremenjen. Skrajšamo pa lahko tiste dela programa, ki jih potrebujemo za izpis, da sta si števili tuji. Števili sta si tuji, ko nismo našli nobenega skupnega delitelja. To se zgodi takrat, ko se je zanka \texttt{while} \emph{odvrtela} do konca in nismo našli nobenega skupnega delitelja, torej je posledično nismo prekinili s stavkom \texttt{break}. Če zanko \texttt{while} dopolnimo z vejo \texttt{else}, se bo ta izvedla natanko takrat, ko zanka ni bila prekinjena s stavkom \texttt{break}, torej takrat, ko nismo našli nobenega skupnega delitelja. Znotraj veje \texttt{else} lahko torej zapišemo, da sta si števili tuji. Na tak način se lahko znebimo spremenljivke \texttt{nasli} in naredimo program krajši in bistveno bolj pregleden.
\begin{lstlisting}[language=Python,numbers=left]
st1 = int(input("Vnesi prvo število: "))
st2 = int(input("Vnesi drugo število: "))

delitelj = 2 # začetna vrednost kandidata

# kandidat/delitelj gre do manjšega
while delitelj <= min(st1, st2): 
    # ali delitelj deli obe števili?
    if st1 % delitelj == 0 and st2 % delitelj == 0:
        print("Števili nista tuji")
        break # lahko prenehamo z iskanjem
    delitelj += 1 
else: # ali se je zanka odvrtela do konca
    # zanke nismo prekinili s stavkom break
    print("Števili sta tuji")
\end{lstlisting}
\end{resitev}